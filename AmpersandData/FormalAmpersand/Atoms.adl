CONTEXT AST IN ENGLISH LATEX

PURPOSE PROCESS Atoms  --HJO: Door een of andere onverklaarbare reden mag je hier geen Atoms van maken, want dat wordt gezien als iets dubbel??
{+Atoms are defined so that they comply with Ampersand's choice to use a representable heterogeneous relational algebra.
-}
PROCESS Atoms
PURPOSE CONCEPT Atom
{+
In order to reason with knowledge, or even express such knowledge (within a context), requires that tangible and intangible things (entities) can be referred to.
We use the word 'Atom' as a generic term that refers to entities that is known to exist in a specific context.
-}
CONCEPT Atom "An atom is an indivisible (unstructured) data element, and an instance of a specific concept."
PURPOSE RELATION repr
{+
Atoms are only useful when they can be distinguished between themselves. 
In Ampersand, the smallest set that atoms need to be distinguished in is a concept.
This means that atoms must have identifiers that distinguish between all atoms in any given concept.
Thus, every atom must have an identifier that identifies it in any of its concepts.
Note that identifiers do not have an intrinsic meaning.
Meaning is 'imposed' on an atom by the concepts that it is a member of, i.e. the relations and rules defined over such concepts.
In the current version of Ampersand, every atom is represented by a finite list of UTF-8 characters.
In future versions, other types of representation will become possible, and may depend on the kind of concept that they are members of. Example of this are ...
-}
--! Please define TType; I do not have any idea what this is about. Until then, there is no way to establish why 'repr' should be INJ.
RELATION repr[Atom*TType] [TOT,INJ]
MEANING "Every atom has a representation, which identifies that atom within every concept that it populates."
PURPOSE RELATION pop
{+
Concepts can be populated with atoms, which gives them meaning.
Ampersand uses relation algebra to reason without mentioning atoms.
As a consequence, Ampersand can serve as a modeling language that reasons about populations of concepts and relations.
-}
RELATION pop[Atom*Concept] [TOT] 
MEANING "If $a\\ \\id{pop}\\ c$, we say that atom $a$ is in the population of concept $c$."
PURPOSE RELATION eq
{+
Since an atom may populate different concepts, but also different atoms that have the same identifier may populate different concepts, it is necessary to know whether or not any two such identifiers refer to the same atom. 
In order to answer such questions, we introduce the notion of 'equality of atoms'.
-}
RELATION eq[Atom*Atom] [UNI,TOT,SUR,INJ,SYM,TRN,RFX]
MEANING "Equality is defined on atoms."
RELATION sub[Concept*Concept]
MEANING "$s\\ \\id{sub}\\ g$ means that each element of concept $s$ is an element of concept $g$ as well."

PURPOSE RULE "equality on Atoms"
{+
The type checking system must guarantee that at runtime, two atoms are only compared for equality if they are part of the same population.
If the type checking system can prove this, then testing of equality on atoms at runtime may be implemented as a simple comparison of only the atom's identifiers.
Therefore, we need a rule that specifies what equality is.
-}
RULE "equality on Atoms" : eq = repr;repr~ /\ pop;(sub\/sub~)*;pop~
MEANING "Two atoms are equal if and only if their representations are equal and they share a same concept."

PURPOSE RULE "specialization"
{+Specialization is required in order to facilitate the reuse of code.
Ampersand defines specialization to allow for static type checking.
The behaviour of specialization is characterized by a rule that says that something specific (e.g. a person) has all the properties of the generic thing from which it is a specialization (e.g. a mammal).
The natural language logic, that states that every person is a mammal is thus reflected in Ampersand.
-}
PURPOSE RULE "specialization" --! This should sometime be (re)moved (to somewhere else)
{+The current way of doing specializations has an odd consequence.
Suppose we have

\begin{verbatim}
CLASSIFY Lemon ISA Citrus
CLASSIFY Orange ISA Citrus
\end{verbatim}

Suppose we have an interface with two editable fields: one expecting a Lemon and the other expecting an Orange.
Now let's do the following exercise: fill in \verb#l1# in the field that expects a lemon and fill in the same atom in the field that expects an orange.
The definition of equality now says that the Orange \verb#l1# and the Lemon \verb#l1# are the same atom.
Adding the following rule to the Ampersand script will prevent that:

\begin{verbatim}
RULE -(I[Orange] /\ I[Lemon]) 
\end{verbatim}
-}
RULE "specialization" : pop;sub |- pop
MEANING "An atom that is an instance of a specialization of $c$ is an instance of $c$ as well."
VIOLATION (TXT "{EX} InsPair;pop;Atom;", SRC I, TXT ";Concept;", TGT I)
ROLE ExecEngine MAINTAINS specialization

RELATION source[Relation*Concept] [UNI,TOT] 
RELATION target[Relation*Concept] [UNI,TOT] 

PURPOSE CONCEPT Pair
{+
In order to populate relations, atoms are assembled in pairs.
In fact, a relation may be regarded as a set of pairs of atoms.
In an information system, the population of relations can change because of edit actions by users in user interfaces.
This means that pairs are inserted into and deleted from relations as time goes by.
-}
CONCEPT Pair "A pair is something that contains two atoms."
RELATION in[Pair*Relation] [UNI,TOT]
RELATION l[Pair*Atom] [UNI,TOT]
RELATION r[Pair*Atom] [UNI,TOT]

-- The following are derivable relations
PURPOSE RULE "source type"
{+In order to know to which concept an atom belongs, we must look at the relation in which a concept resides.
Note that atoms cannot exist outside a population, since pop is a total relation.
-}
RULE "source type" : l~;in;source |- pop
MEANING "Every atom at the left of a pair is in the population of the source concept of that relation."
RULE "target type" : r~;in;target |- pop
MEANING "Every atom at the right of a pair is in the population of the target concept of that relation."
VIOLATION (TXT "{EX} InsPair;pop;Atom;", SRC I, TXT ";Concept;", TGT I)

RULE "garbage" : pop |- l~;in;source \/ r~;in;target
VIOLATION (TXT "{EX} DelPair;pop;Atom;", SRC I, TXT ";Concept;", TGT I)
ROLE ExecEngine MAINTAINS garbage, "source type", "target type"
ENDPROCESS

ENDCONTEXT