CONTEXT RAP IN ENGLISH
--! It is allowed to change texts and/or the order of texts IF AND ONLY IF this is also done in the corresponding Haskell files !--
INCLUDE "AST.ifc"
INCLUDE "Rules.adl"
INCLUDE "Expressions.adl"
INCLUDE "Views.adl"

{-RJ/20150207: Opmerkingen n.a.v. een vluchtige code-inspectie van dit bestand
1) Het is nu nog wel, maar binnen RAP niet meer, mogelijk om een Pattern, Context en/of Concept dezelfde naam te geven (vanwege de INJectiviteit van relaties als name, ptnm). Deze nieuwe beperking lijkt me onwenselijk.
      Reactie HJO/20150207: Die snap ik niet. Twee Concepten met dezelfde naam zijn hetzelfde Concept. Een Pattern mag dezelfde naam hebben als een Concept. Daarmee zijn de uiteraard niet identiek. Een Pattern is nou een maal geen Concept. Dit is nu zo geregeld in RAP. Als je punt is, dat twee verschillende Concepten best dezelfde naam zouden mogen hebben, dan hebben we een issue. Maar ik denk niet dat je dit bedoelt.
2) VIEWs (zoals 'VIEW Gen') horen m.i. niet in dit bestand thuis, maar daar waar de UI wordt gespecificeerd. IDENTs horen wel in dit bestand thuis.
      Reactie HJO/20150207: Helemaal mee eens. Gaan we doen. 
3) Van "RELATION decprps[Declaration*PropertyRule]" zou ik denken dat hij niet alleen INJ, maar ook SUR moet zijn.
      Reactie HJO/20150207: Dat denk ik ook. Leuk is, dat dit geen invloed heeft op de meatgrinder. Immers, die zorgt alleen maar voor de juiste populatie van Declarations. Als blijkt dat we dan overtredingen krijgen, dan gaan we dat meemaken...
-}

REPRESENT Purpose TYPE BIGALPHANUMERIC
REPRESENT Meaning TYPE BIGALPHANUMERIC
REPRESENT ConceptDefinition TYPE BIGALPHANUMERIC

PATTERN Context
CONCEPT Context "A context is the root of the abstract syntax tree of a valid Ampersand rule specification." 
IDENT Context: Context(name[Context*ContextIdentifier])  
REPRESENT ContextIdentifier TYPE ALPHANUMERIC
RELATION name[Context*ContextIdentifier] [UNI,TOT,INJ]
MEANING "The name of a context."
RELATION valid[Rule*Context] [UNI]
RELATION usedPatterns[Context*Pattern]
MEANING "The patterns in a context."
RELATION concs[Context*Concept]
MEANING "A concept, mentioned anywhere in a context."
RELATION allDeclarations[Context*Relation]
MEANING "A relation declared in a context"
RELATION gens[Context*Gen]
MEANING "The user-defined generalization rules in a context."
ENDPATTERN

PATTERN Patterns
CONCEPT Pattern "A pattern is a container for relation declarations and rule definitions"
IDENT Pattern: Pattern(name[Pattern*PatternIdentifier])
REPRESENT PatternIdentifier TYPE ALPHANUMERIC
RELATION name[Pattern*PatternIdentifier] [UNI,TOT,INJ]
MEANING "The name of a pattern."
RELATION rules[Pattern*Rule]
MEANING "The user-defined rules in a pattern."
RELATION declarations[Pattern*Declaration]
MEANING "The relation declarations in a pattern."
RELATION purpose[Pattern*Purpose]
MEANING "The purposes of a pattern."


ENDPATTERN

PATTERN Specialization
VIEW Gen: Gen( TXT "CLASSIFY ", genspc;name{-[Concept*Identifier]-} , TXT " ISA " , gengen;name{-[Concept*Identifier]-} )
RULE "eq gen": gengen;gengen~ /\ genspc;genspc~ |- I
MEANING "Two generalization rules are identical when the specific concepts are identical and the generic concepts are identical."

RELATION gengen[Gen*Concept] [UNI,TOT]
MEANING "A generalization rule refers to one more generic concept."
RELATION genspc[Gen*Concept] [UNI,TOT]
MEANING "A generalization rule refers to one more specific concept."

--PURPOSE RULE specialization
--{+Specialization has the consequence that an atom is not necessarily an instance of one concept only.
--If limes are citrus fruits, then every lime is not only lime but a citrus fruit as well.
---}
--RELATION instanceOf[Atom*Concept] [TOT] 
--RULE specialization : instanceOf;genspc~;gengen |- instanceOf
--MEANING "Every instance of a specialized concept is an instance of the generic concept too."

ENDPATTERN

PATTERN Declaration
--VIEW Declaration: Declaration( name , TXT "::", sign;src;name[Concept*Identifier] ,TXT " * ", sign;tgt;name[Concept*Identifier] )
--IDENT Declaration: Declaration( name, sign;src;name, sign;tgt;name )
--CLASSIFY Declaration ISA Relation
RULE "eq declaration": name;name~ /\ sign;src;(sign;src)~ /\ sign;tgt;(sign;tgt)~ |- I[Declaration]
MEANING "The unique signature of a relation consists of a relation name, a source concept, and a target concept."

RELATION name[Declaration*Identifier] [UNI] --TODO: Should be TOT, but this is only true for user-defined declarations. TODO: I[<Concept>] is a declaration? And what about V?? In Haskell, it currently is.
MEANING "The name of a relation."
RELATION sign[Declaration*Signature] [UNI] --TODO: Should be TOT, but this is only true for user-defined declarations. TODO: I[<Concept>] is a declaration? And what about V?? In Haskell, it currently is.
MEANING "The sign of a declaration."
RELATION decprps[Declaration*PropertyRule] [INJ]
MEANING "The properties of a relation."

VIEW Signature: Signature( TXT "[" , src;name[Concept*Identifier] , TXT "*" , tgt;name[Concept*Identifier] , TXT "]" )

RELATION src[Signature*Concept] [UNI,TOT]
MEANING "The source of a signature."
ROLE Ampersand MAINTAINS "TOT src::Signature*Concept", "TOT tgt::Signature*Concept"
RELATION tgt[Signature*Concept] [UNI,TOT]
MEANING "The target of a signature."

CONCEPT PropertyRule "A property rule is a rule, that is a property of a user-declared relation"
CLASSIFY PropertyRule ISA Rule
CONCEPT Property "UNI<|>TOT<|>INJ<|>SUR<|>RFX<|>IRF<|>SYM<|>ASY<|>TRN<|>PROP"
RULE "property enum": I[Property] |- 'UNI' \/ 'TOT' \/ 'INJ' \/ 'SUR' \/ 'RFX' \/ 'IRF' \/ 'SYM' \/ 'ASY' \/ 'TRN' \/ 'PROP'
MEANING "There are eleven tokens, that can be used to define properties on a relation. -> is syntactic suger for UNI and TOT; UNI means univalent; TOT means total; INJ means injective; SUR means surjective; RFX means reflexive; IRF means irreflexive; SYM means symmetric; ASY means antisymmetric; TRN means transitive; and PROP means symmetric and antisymmetric."
RELATION decprL[Declaration*String] [UNI]
MEANING "The prefix of the pragma of a relation."
RELATION decprM[Declaration*String] [UNI]
MEANING "The infix of the pragma of a relation."
RELATION decprR[Declaration*String] [UNI]
MEANING "The suffix of the pragma of a relation."
RELATION decmean[Declaration * Meaning]
MEANING "The meanings of a relation."
RELATION decpurpose[Declaration * Purpose]
MEANING "The purposes of a relation."
RELATION in[PairID*Declaration]
MEANING "The population of a relation."

--HJO,20150420, uitgezet, vanwege gebruik van Atoms.adl: RULE "entity integrity of relation": left;left~ /\ right;right~ /\ in;in~ |- I
--HJO,20150420, uitgezet, vanwege gebruik van Atoms.adl: MEANING "There cannot be two relationships in the population of a relation with the same source and same target."
--HJO,20150420, uitgezet, vanwege gebruik van Atoms.adl: MESSAGE "Every tuple in a relation is unique, or, no two tuples in the population of a relation may have the same source and target atoms. Addition of a duplicate tuple is not permitted. It is a violation of the <b>Entity integrity</b> rule for this relation."
--HJO,20150420, uitgezet, vanwege gebruik van Atoms.adl: VIOLATION (TXT "A tuple with the same source and target atoms ", SRC I, TXT " already exists." )

--RULE "typed domain": decpopu;left;cptos~;order  |- sign;src;order
--MEANING "The atoms in the domain of a relation belong to the same class as the source of that relation."
--MESSAGE "You try to add a tuple with a source atom, that is not in the population of the source of the relation. This is a violation of the type of the tuple. TIP: enter text in the left input field to get a shorter pick list. Note on ISA-relations: You can make an atom more specific by moving it to the population of a more specific concept."
--VIOLATION (TXT "Source atom ", TGT I, TXT " is not in the population of ", SRC sign;src)

--RULE "typed codomain": decpopu;right;cptos~;order |- sign;tgt;order
--MEANING "The atoms in the codomain of a relation belong to the same class as the target of that relation."
--MESSAGE "You try to add a tuple with a target atom, that is not in the population of the target of the relation. This is a violation of the type of the tuple. TIP: enter text in the right input field to get a shorter pick list. Note on ISA-relations: You can make an atom more specific by moving it to the population of a more specific concept."
--VIOLATION (TXT "Target atom ", TGT I, TXT " is not in the population of ", SRC sign;tgt)
ENDPATTERN

PROCESS Plugs -- This pattern documents the semantics of plugs as of november 2014.
RELATION maintains[Plug*Rule]
RELATION in[Concept*Plug] --TODO: 'Nearly TOT: All concepts are in a plug, except ONE".
RELATION in[Declaration*Plug] [TOT]

-- Rules
ROLE Ampersand MAINTAINS "All isas in one plug"
RULE "All isas in one plug" : (-(genspc~;gengen;in[Concept*Plug]) \/ in[Concept*Plug]) /\ (-(gengen~;genspc;in[Concept*Plug]) \/ in[Concept*Plug])
MEANING "If a concept is stored in a plug, then every generalization of that concept is stored in the same plug."
ENDPROCESS

PATTERN ToDo -- This pattern contains stuff still to be done.
RELATION rrviols[Rule*Violation]
ENDPATTERN
ENDCONTEXT


