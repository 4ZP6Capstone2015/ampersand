module DatabaseDesign.Ampersand_Prototype.Generate (generateAll) where

import DatabaseDesign.Ampersand_Prototype.CoreImporter  
import Prelude hiding (writeFile,readFile,getContents,putStr,putStrLn)
import Data.List
import System.FilePath               
import DatabaseDesign.Ampersand_Prototype.Version 

import DatabaseDesign.Ampersand_Prototype.RelBinGenSQL

generateAll :: Fspc -> Options -> IO ()
generateAll fSpec opts =
 do { verboseLn opts "Experimental Generation"
    ; writePrototypeFile "Interfaces.php" $ generateInterfaces fSpec opts
    }
  where
    writePrototypeFile fname content =
     do { verboseLn opts ("  Generating "++fname)
        --; verboseLn opts $ content
        ; writeFile (combine (dirPrototype opts) fname) content
        }
 
  
generateInterfaces fSpec opts = genPhp "Generate.hs" "Interfaces.php" $
  phpPreliminaries ++
  ["require \"php/DatabaseUtils.php\";"
  , ""
  , "printBinaryTable(DB_doquer('"++dbName opts++"', getQueryOverview_as()));"
  , "print_r( getCoDomainAtoms( 'Hello', '2', getQueryId_notIdentifies() ));"
  , ""
  , "function getCoDomainAtoms($dbName, $atom, $selectRel) {"
  , "  return targetCol(DB_doquer($dbName, selectCoDomain($atom, $selectRel)));"
  , "}"
  , ""
  , "function selectCoDomain($atom, $selectRel) {"
  , "  return 'SELECT DISTINCT `tgt` FROM ('.$selectRel.') as results where src='.$atom;"
  , "}"
  , ""  ] ++
  concatMap (generateInterface fSpec opts) allInterfaces ++
  [ ""
  , "echo 'einde';"
  ]     
 where allInterfaces = interfaceS fSpec ++ interfaceG fSpec

generateInterface fSpec opts interface =
  [ "// "++name interface ++":" ] ++
  traverse fSpec opts [] (ifcObj interface) 
  
traverse fSpec opts parentObjs object = ("// "++(name object ++ " " ++ show (objctx object))) :
  generateQuery fSpec opts (toPhp $ intercalate "_" $ parentObjs ++ [name object]) (objctx object) ++
  case objats object of
      [] -> []
      objects -> concatMap (traverse fSpec opts (parentObjs ++ [name object])) objects 
  
-- could be constants, but then we need to define them before the place where they are used..
generateQuery :: Fspc -> Options -> String -> Expression -> [String]
generateQuery fSpec opts name exp =
  [ "function getQuery"++name++"() {"
  , case selectExpr fSpec 25 "src" "tgt" exp of
       Just selectQuery -> "  return '"++selectQuery++"';"
       Nothing          -> "  return null;" -- todo give an error                 
  , "}\n"]
 
toPhp str = map replace str
 where replace ' ' = '_'
       replace c   = c
  
-- GenUtil
phpPreliminaries = -- Maybe this will be put in an imported Php module
  [ "error_reporting(E_ALL); "
  , "ini_set(\"display_errors\", 1);"
  ]

-- generatorModule is the Haskell module responsible for generation, makes it easy to track the origin of the php code
genPhp generatorModule moduleName contentLines = unlines $
  [ "<?php"
  , "// module "++moduleName++" generated by "++generatorModule
  , "// "++prototypeVersionStr
  ] ++ replicate 2 "" ++ contentLines ++
  [ "?>"
  ]
  
indent n lines = [ replicate n ' ' ++ line | line <- lines ]
