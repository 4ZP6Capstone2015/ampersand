module DatabaseDesign.Ampersand_Prototype.Generate (generateAll) where

import DatabaseDesign.Ampersand_Prototype.CoreImporter  
import Prelude hiding (writeFile,readFile,getContents,putStr,putStrLn)
import Data.List
import Data.Maybe
import System.FilePath               
import DatabaseDesign.Ampersand_Prototype.Version 

import DatabaseDesign.Ampersand_Prototype.RelBinGenSQL

generateAll :: Fspc -> Options -> IO ()
generateAll fSpec opts =
 do { verboseLn opts "Experimental Generation"
    ; writePrototypeFile "Interfaces.php" $ generateInterfaces fSpec opts
    }
  where
    writePrototypeFile fname content =
     do { verboseLn opts ("  Generating "++fname)
        --; verboseLn opts $ content
        ; writeFile (combine (dirPrototype opts) fname) content
        }
 
  
generateInterfaces fSpec opts = genPhp "Generate.hs" "Interfaces.php" $
  [ "$dbName = "++showPhpStr (dbName opts)++";"
  , ""
  , "$relationTables ="
  , "  array" ] ++
       (addToLastLine ";" $ indent 4 $ blockParenthesize -- todo: why do we get a list of tables and src/tgtCols??
         [ [showPhpStr rnm++" => array (table => "++showPhpStr table++", srcCol => "++showPhpStr srcCol++", tgtCol => "++showPhpStr tgtCol++" )"] 
           | rel@(Rel {relnm = rnm}) <- concat usedRels, (table,srcCol,tgtCol) <- sqlRelPlugNames fSpec (ERel rel)]) ++
  [ ""
  , "$allInterfaceObjects ="
  , "  array" ] ++
       (addToLastLine ";" $ indent 4 $ blockParenthesize interfaceLines)
 where allInterfaces = interfaceS fSpec ++ interfaceG fSpec
       (interfaceLines, usedRels) = unzip $ map (generateInterface fSpec opts) allInterfaces

generateInterface fSpec opts interface =
  ( [ "// Top-level interface "++name interface ++":"
    , showPhpStr (name interface) ++" => " ] ++
    interfaceObjectsLines
  , usedRels
  )
 where (interfaceObjectsLines, usedRels) = genInterfaceObjects fSpec opts 1 (ifcObj interface)  


-- two arrays: one for the object and one for the list of subinterfaces
genInterfaceObjects :: Fspc -> Options -> Int -> ObjectDef -> ([String],[Relation])
genInterfaceObjects fSpec opts depth object = 
  ( indent (depth*2) $
    [ "array ( 'name' => "++showPhpStr (name object)
    , "      // relation: "++showPhpStr (show (objctx object))  -- escape for the pathological case that one of the names in the relation contains a newline
    ] ++ case objctx object of
           ERel (Rel { relnm = rnm}) -> -- only support editing on user-specified relations (no expressions, and no I or V)
             [ "      , 'relation' => "++showPhpStr rnm
             , "      , 'relationIsFlipped' => False" 
             ]
           EFlp (ERel (Rel { relnm = rnm})) -> -- and on flipped versions of those relations
             [ "      , 'relation' => "++showPhpStr rnm
             , "      , 'relationIsFlipped' => True" 
             ]          
           _ ->
            [ "      , 'relation' => ''" 
            , "      , 'relationIsFlipped' => ''" 
            ]          
    ++     
    [ "      , 'concept' => "++showPhpStr (show (target $ objctx object)) -- only needed for top level
    , "      , 'isUnivalent' => " ++ (showPhpBool $ isUni (objctx object))
    , "      , 'sqlQuery' => '" ++ (fromMaybe "" $ selectExpr fSpec 25 "src" "tgt" $ objctx object) ++ "'" -- todo give an error for Nothing                                                  
    , "      , 'subInterfaces' =>"
    , "          array"
    ] ++ (indent 10 $ blockParenthesize $ interfaceObjectsLines) ++
    [ "      )"
    ]
  , concat usedRelss ++ case objctx object of
                         ERel r@(Rel {})        -> [r] 
                         EFlp (ERel r@(Rel {})) -> [r]
                         _                      -> []
  )
 where (interfaceObjectsLines, usedRelss) = unzip $ map (genInterfaceObjects fSpec opts $ depth + 1) $ objats object
 
blockParenthesize :: [[String]] -> [String]
blockParenthesize [] = ["()"]
blockParenthesize liness = concat [ zipWith (++) (sep:repeat "  ") (lines::[String]) | (sep, lines) <- zip ("( ":repeat ", ") liness ] ++ [")"]
-- [["line"], ["line1", "line2", "line3"],["linea", "lineb"] ->
-- ( line
-- , line1
--   line2
--   line3
-- , linea
--   lineb
-- )

addToLastLine :: String -> [String] -> [String]
addToLastLine str [] = [str] 
addToLastLine str lines = init lines ++ [last lines ++ str] 
  
toPhp str = map replace str
 where replace ' ' = '_'
       replace c   = c
 
showPhpStr str = "'"++escapePhpStr str++"'"

-- NOTE: we assume a single quote php string, so $ and " are not escaped
escapePhpStr cs = concat [fromMaybe [c] $ lookup c [('\'', "\\'"),('\\', "\\\\"),('\n', "\\n")] | c<-cs ] -- escape '   \   \n
-- todo: escape everything else (unicode, etc)

showPhpBool b = if b then "true" else "false"

-- generatorModule is the Haskell module responsible for generation, makes it easy to track the origin of the php code
genPhp generatorModule moduleName contentLines = unlines $
  [ "<?php"
  , "// module "++moduleName++" generated by "++generatorModule
  , "// "++prototypeVersionStr
  ] ++ replicate 2 "" ++ contentLines ++
  [ "?>"
  ]
  
indent n lines = [ replicate n ' ' ++ line | line <- lines ]
