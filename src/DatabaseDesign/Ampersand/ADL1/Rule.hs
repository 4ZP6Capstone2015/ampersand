{-# OPTIONS_GHC -Wall -XUndecidableInstances -XFlexibleContexts -XMultiParamTypeClasses -XFlexibleInstances #-}
module DatabaseDesign.Ampersand.ADL1.Rule    ( Rule(..),mapRule,Rules
                   , RuleType(..)
                   , consequent, antecedent, ruleType, normExpr, rulefromProp, isaRule, ruleviolations)     
where
   import DatabaseDesign.Ampersand.Input.ADL1.FilePos             ( FilePos(..), Numbered(..))
   import DatabaseDesign.Ampersand.Basics                         ( Identified(..))
   import DatabaseDesign.Ampersand.ADL1.Concept                   ( Concept(..), Conceptual(..), SpecHierarchy, Signaling(..))
   import DatabaseDesign.Ampersand.ADL1.MorphismAndDeclaration    ( Relation(..), Declaration(..), Association(..) ,Relational(..), mIs)
   import DatabaseDesign.Ampersand.ADL1.Expression                ( Expression(..), mapExpression, notCp)
   import DatabaseDesign.Ampersand.ADL1.Pair                      ( Pairs)
   import DatabaseDesign.Ampersand.ADL1.Prop                      ( Prop(..))
   import DatabaseDesign.Ampersand.Classes.Populated              (contents)
   import DatabaseDesign.Ampersand.TypeInference.InfLibAG         ( InfTree(..) )
   import DatabaseDesign.Ampersand.Misc.Explain
   import DatabaseDesign.Ampersand.Misc  
                                         
   type Rules rel = [Rule rel]
   data Rule rel =
  -- Ru c antc p cons expla sgn nr pn
        Ru { rrsrt    :: RuleType          -- ^ One of the following:
                                           --    | Implication if this is an implication;
                                           --    | Equivalence if this is an equivalence;
                                           --    | Truth  if this is an ALWAYS expression.
           , rrant    :: Expression rel -- ^ Antecedent
           , rrfps    :: FilePos            -- ^ Position in the Ampersand file
           , rrcon    :: Expression rel -- ^ Consequent
--           , r_cpu :: Expressions r       -- ^ This is a list of subexpressions, which must be computed.
           , rrxpl    :: [AutoExplain]     -- ^ Ampersand generated explanations (for all known languages)
           , rrtyp    :: (Concept,Concept) -- ^ Sign of this rule
           , rrtyp_proof :: Maybe (InfTree,Expression rel)
           , rrdcl    :: Maybe (Prop,Declaration Concept)  -- ^ The property, if this rule originates from a property on a Declaration
           , runum    :: Int               -- ^ Rule number
           , r_pat    :: String            -- ^ Name of pattern in which it was defined.
           , r_usr    :: Bool              -- ^ True if this rule was specified explicitly as a rule in the Ampersand script; False if it follows implicitly from the Ampersand script and generated by a computer
           , r_sgl    :: Bool              -- ^ True if this is a signal; False if it is an ALWAYS rule
           , srrel    :: Declaration Concept       -- ^ the signal relation
           } deriving (Eq)

   mapRule :: (a->b) -> Rule a -> Rule b
   mapRule f r = r { rrant = mapExpression f (rrant r)
                   , rrcon = mapExpression f (rrcon r)
                   , rrtyp_proof = case rrtyp_proof r of
                                    Nothing       -> Nothing
                                    Just (tree,e) -> Just (tree, mapExpression f e)
                   }

   data RuleType = Implication | Equivalence | Truth | Generalization deriving (Eq,Show)

   isaRule :: Rule r -> Bool    -- tells whether this rule was declared as an ISA rule
   isaRule Ru{rrfps=FilePos(_,_,str)} = str == "ISA"
   isaRule _ = False

--   instance Ord (Rule r) where
--    compare r r' = compare (runum r) (runum r')

   instance Show r => Show (Rule r) where
    showsPrec _ x =
       case x of
          Ru{rrsrt = Implication   } -> showString$ show(rrant x) ++ " |- " ++ (show$rrcon x)
          Ru{rrsrt = Equivalence   } -> showString$ show(rrant x) ++ " = "  ++ (show$rrcon x)
          Ru{rrsrt = Truth         } -> showString$ show(rrcon x)
          Ru{rrsrt = Generalization} -> showString ""
        
   instance Numbered (Rule r) where
    pos r = rrfps r
    nr r  = runum r

   instance Identified (Rule r) where
    name r = if null (name (srrel r)) then "Rule"++show (runum r) else name (srrel r)
    
   instance Association (Rule r) Concept where
    source r  = fst (rrtyp r)
    target r  = snd (rrtyp r)

   instance Signaling (Rule r) where
    isSignal r = r_sgl r
   
   instance (Eq r,Show c,Show r,SpecHierarchy c,Conceptual c,Relational r c,Identified r) =>
            Relational (Rule r) Concept where
    multiplicities _  = []
    flp r = r{rrant = if rrsrt r == Truth
                      then error ("!Fatal (module Rule 83): illegal call to antecedent in flp ("++show r++")")
                      else flp (rrant r)
             ,rrcon = flp (rrcon r)
             ,rrtyp = (target r,source r)
             }
  --  isIdent r = error ("!Fatal (module Rule 88): isIdent not applicable to any rule:\n "++showHS "" r)
--    isIdent r = isIdent (normExpr r)
    isProp r  = isProp (normExpr r)

    isTrue r  = case ruleType r of
                 Truth       -> isTrue (consequent r)
                 Implication -> isFalse (antecedent r) || isTrue (consequent r)
                 Equivalence -> antecedent r == consequent r
                 Generalization -> error ("!Fatal (module Rule 96): isTrue not defined for a Generalisation.")
    isFalse r = case ruleType r of
                 Truth       -> isFalse (consequent r)
                 Implication -> isTrue (antecedent r) && isFalse (consequent r)
                 Equivalence -> notCp (antecedent r) == consequent r
                 Generalization -> error ("!Fatal (module Rule 101): isFalse not defined for a Generalisation.")
    isNot r   | ruleType r==Truth = isNot (consequent r)
              | otherwise         = False  -- TODO: check correctness!
    isIdent r = isIdent (normExpr r)


   normExpr :: Show r => Rule r -> Expression r
   normExpr rule
    | ruleType rule==Truth = consequent rule
    | ruleType rule==Implication = Fux [Cpx (antecedent rule), consequent rule]
    | ruleType rule==Equivalence = Fix [ Fux [     antecedent rule , Cpx (consequent rule)]
                                       , Fux [Cpx (antecedent rule),      consequent rule ]]
    | otherwise          = error("!Fatal (module Rule 113): Cannot make an expression of "++show rule)

   ruleType :: Rule r -> RuleType
   ruleType r = rrsrt r

   antecedent :: Show r => Rule r -> Expression r
   antecedent r = case r of
                   Ru{rrsrt = Truth} -> error ("!Fatal (module Rule 120): illegal call to antecedent of rule "++show r)
                   Ru{} -> rrant r
                   
   consequent :: Rule r -> Expression r
   consequent r = rrcon r

   ruleviolations :: Rule (Relation Concept) -> Pairs
   ruleviolations (Ru{rrsrt=rtyp,rrant=ant,rrcon=con,rrtyp=t}) 
       | rtyp==Truth = (Tm (V [] t) (-1)) `contentsnotin` con  --everything not in con
       | rtyp==Implication = ant `contentsnotin` con 
       | rtyp==Equivalence = ant `contentsnotin` con ++ con `contentsnotin` ant 
       where
       contentsnotin x y = [p|Just c<-[contents x],p<-c,Just c'<-[contents y], not$elem p c']
   ruleviolations _ = []
 
   rulefromProp :: Prop -> Declaration Concept -> Rule (Relation Concept)
   rulefromProp prp d@(Sgn{})
      = Ru { rrsrt = case prp of
                        Uni-> Implication
                        Tot-> Implication
                        Inj-> Implication
                        Sur-> Implication
                        Sym-> Equivalence
                        Asy-> Implication
                        Trn-> Implication
                        Rfx-> Implication
           , rrant = case prp of
                        Uni-> F [flp r,r] 
                        Tot-> i$sign$F [r,flp r]
                        Inj-> F [r,flp r]
                        Sur-> i$sign$F [flp r,r]
                        Sym-> r
                        Asy-> Fix [flp r,r]
                        Trn-> F [r,r]
                        Rfx-> i$sign r 
           , rrfps = pos d
           , rrcon = case prp of
                        Uni-> i$sign$F [flp r,r]
                        Tot-> F [r,flp r]
                        Inj-> i$sign$F [r,flp r]
                        Sur-> F [flp r,r]
                        Sym-> flp r
                        Asy-> i$sign$Fix [flp r,r]
                        Trn-> r
                        Rfx-> r
           , rrxpl = [string2AutoExplain (defaultFlags {language = English}) (
                      case prp of
                        Sym-> name d++"["++name (source d)++"*"++name (source d)++"] is symmetric."    
                        Asy-> name d++"["++name (source d)++"*"++name (source d)++"] is antisymmetric."
                        Trn-> name d++"["++name (source d)++"*"++name (source d)++"] is transitive."
                        Rfx-> name d++"["++name (source d)++"*"++name (source d)++"] is reflexive."
                        Uni-> name d++"["++name (source d)++"*"++name (target d)++"] is univalent"
                        Sur-> name d++"["++name (source d)++"*"++name (target d)++"] is surjective"
                        Inj-> name d++"["++name (source d)++"*"++name (target d)++"] is injective"
                        Tot-> name d++"["++name (source d)++"*"++name (target d)++"] is total"
                        )] ++
                     [string2AutoExplain (defaultFlags {language = Dutch}) (
                      case prp of
                        Sym-> name d++"["++name (source d)++"*"++name (source d)++"] is symmetrisch."    
                        Asy-> name d++"["++name (source d)++"*"++name (source d)++"] is antisymmetrisch."
                        Trn-> name d++"["++name (source d)++"*"++name (source d)++"] is transitief."
                        Rfx-> name d++"["++name (source d)++"*"++name (source d)++"] is reflexief."
                        Uni-> name d++"["++name (source d)++"*"++name (target d)++"] is univalent"
                        Sur-> name d++"["++name (source d)++"*"++name (target d)++"] is surjectief"
                        Inj-> name d++"["++name (source d)++"*"++name (target d)++"] is injectief"
                        Tot-> name d++"["++name (source d)++"*"++name (target d)++"] is totaal"
                        )] 
           , rrtyp = case prp of
                        Uni-> sign$F [flp r,r]
                        Tot-> sign$F [r,flp r]
                        Inj-> sign$F [r,flp r]
                        Sur-> sign$F [flp r,r]
                        Sym-> h$sign r
                        Asy-> h$sign r
                        Trn-> h$sign r
                        Rfx-> h$sign r
           , rrtyp_proof = Nothing
           , rrdcl = Just (prp,d)         -- For traceability: The original property and declaration.
           , runum = 0                    -- Rules will be renumbered after enriching the context
           , r_pat = decpat d             -- For traceability: The name of the pattern. Unknown at this position but it may be changed by the environment.
           , r_usr = False                
           , r_sgl = False                
           , srrel = d{decnm=show prp++name d}
           }
          where
           i (x,y) | x==y = Tm ( mIs x) (-1)
                   | otherwise = error ("!Fatal (module Rule 206): Bad multiplicity rule, the identity must be homogeneous.")
           h (x,y) | x==y = (x,y)
                   | otherwise = error ("!Fatal (module Rule 208): Bad homogeneous rule, the relation must be homogeneous.")
           r:: Expression (Relation Concept)
           r = Tm rel (-1)
               where rel = Rel { relnm  = name d
                               , relpos = pos d
                               , relats = []
                               , relsrc = desrc d
                               , reltrg = detrg d
                               , relyin = True
                               , reldcl = d
                               }
   rulefromProp _ _ = error ("!Fatal (module Rule 219): Properties can only be set on user-defined declarations.")

{- TODO -> Wordt de isa rule gehandhaaft? Zie ook functie isaRule in Rule.hs
  rulefromgen :: Gen -> Rule r
  rulefromgen g
    = Left$Ru
         Implication    -- Implication of Equivalence
         (Tm (mIs spc)(-1)) -- left hand side (antecedent)
         (genfp g)      -- position in source file
         (Tm (mIs gen)(-1)) -- right hand side (consequent)
         []             -- explanation
         (gen,gen)      -- The type
         Nothing        -- no proof of the type
         Nothing        -- This rule was not generated from a property of some declaration.
         0              -- Rule number. Will be assigned after enriching the context
         (genpat g)     -- For traceability: The name of the pattern. Unknown at this position but it may be changed by the environment.
         False          -- This rule was not specified as a rule in the Ampersand script, but has been generated by a computer
         False          -- This is not a signal rule
         (Sgn (name gen++"ISA"++name spc) gen gen [] "" "" "" [] "" (genfp g) 0 False False "")        
    where
    spc = (genspc g)
    gen = (gengen g) 
-}

