-- do not edit; automatically generated by UU_AG
module AGtry where

import Char (isDigit) -- more from this module: Alpha,chr,ord,digitToInt,intToDigit,isAlphaNum,toUpper,toLower,isUpper)
import CommonClasses (  Identified(name)
                      , Collection(isc,(>-),uni))
import UU_Scanner
import Auxiliaries (chain, eqClass, commaEng, rd, sord, sort')
import Classification
         ( Classification(Cl)
         ,locatesF,makeClassificationsF,preCl,mapCl)
import Typology (Inheritance(Isa),genEq,typology)
import CC_aux 
         (  Architecture(Arch)
          , Context(Ctx)
          , Concept(Anything, NOthing, C, S)
          , ConceptDef(Cd)
          , Declaration(Sgn, Vs, Isn, Iscompl)
          , Rule(Ru,Sg,Gc)
          , Gen(G)
          , declarations
          , Expressions
          , Pattern(Pat)
          , posNone
          , Prop(Uni,Tot,Inj,Sur,Sym,Asy,Trn,Rfx)
          , Morphic(isIdent), Gens, Declarations, GenR, Contexts
          , Language( declaredRules, multRules, rules, signals, specs, patterns, objectdefs, isa )
          , showADL, source, target, idsOnly, concs, showHS
          , Morphism(Mph,I,V)
          , contents, put_gE, makeConceptSpace, pMeaning
          , Expression(Fu,Fi,Fd,Tc,F,Tm,K0,K1,Cp)
          , FilePos(FilePos), ConceptDefs, Concepts
          , Pairs, Paire, Rules, Morphisms, Patterns
          , sign, anything, shSigns, gEtabG, order, flp
          , isMph, mIs
          , ObjectDef(Obj), ObjDefs, ctx, KeyDef(Kd), KeyDefs, Population(Popu), Populations
          , nr, pos, multiplicities, declaration, renumberRules
          , inline
         )

diagl = 27
diagc = 0

chop [x]    = []
chop (x:xs) = ([x],xs): [(x:l, r)| (l,r)<-chop xs]
chop []     = []

-- (l,r) `elem` chop xs => not (null l) && not (null r)
-- Proof:
-- a) The theorem holds for all xs of length <= 1.
-- b) Suppose the theorem holds for all xs of length <= n, with xs::[C]
--    The induction hypothesis is therefore:
--    b.0) Assume (induction hypothesis): (l,r) `elem` chop xs && length xs<=n => not (null l) && not (null r)
--    b.1) let x::C
--    b.2)      (l,r)<-chop xs
--         implies    {semantics of list comprehension}
--              (l,r) `elem` chop xs
--         implies    {let length xs<=n and induction hypothesis}
--              not (null l) && not (null r)
--    b.3)
--              chop (x:xs) = ([x],xs): [(x:l, r)| (l,r)<-chop xs]
--         implies    {assume length xs<=n, then by b.2}
--              not (null l) && not (null r)
--         implies    {The first clause in the definition of chop ensures: not (null xs)}
--              not (null (x:l)) && not (null r) && not (null [x]) && not (null xs)
--    b.4) TODO: finish proof.

mkCtxAG :: [(Context,(Gens,Declarations))] -> String -> Classification (Context,(Gens,Declarations))
mkCtxAG ctxs ctxName
 = if null ctTrees
   then error ("!Error of type 0: unknown context "++ctxName
               ++".\ntesting: length ctxs="++show (length ctxs)
               ++if length ctxs>1
                 then ".\nPick one of "++chain ", " (map (name.fst) (tail ctxs))++" or "++(name.fst.head) ctxs
                 else if null ctxs then "No context available" else ".\nPick "++(name.fst.head) ctxs
              ) else
   let ecl = [head cl|cl<-eqClass (==) (map (name.fst) ctxs), length cl>1] in
   if null ecl then head ctTrees else
   error ("!Error of type 0: multiple contexts carrying the name "++commaEng "and" ecl++".")
   where
    ctTrees = [t|tree<-trees, t<-locatesF ((==ctxName).name.fst) tree]
-- multiple ctTrees may occur if contexts are used multiply in different ctTrees.
    trees = makeClassificationsF (name.fst) tuples++[Cl s []| s<-singles]
            where tuples = [ ((spc,(mG,mD)),(gen,(mG',mD')))
                           | (spc@(Ctx nm on isa world dc ds cs ks os pops),(mG,mD))<-ctxs, o<-on
                           , (gen,(mG',mD'))<-ctxs,name gen==o]
                  singles= [ (spc,(mG,mD))
                           | (spc,(mG,mD))<-ctxs, not (name spc `elem` rd [name c|(s,g)<-tuples, (c,m)<-[s,g]])]

lubb gE a b = if a `gE` b then b else a
ordd gE a b = a `gE` b || b `gE` a

-- irred removes redundancy from a list of declarations.
-- Intended for use in the type checker AGtry only.
-- Precondition: a `gEq` a' && b `gEq` b' || a' `gEq` a && b' `gEq` b

irredC :: GenR -> [Concept] -> [Concept]
irredC gE cs = map (foldr1 lub) (eqClass order cs)
               where a `lub` b   = if a `gE` b then b else a
                     a `order` b = a `gE` b || b `gE` a
irredT :: GenR -> [(Concept,Concept)] -> [(Concept,Concept)]
irredT gE ccs = map (foldr1 lub) (eqClass order ccs)
                where (a,a') `lub` (b,b')   = if a `gE` b && a' `gE` b' then (b,b') else (a,a')
                      (a,a') `order` (b,b') = (a `gE` b && a' `gE` b') || (b `gE` a && b' `gE` a')
irredS :: GenR -> [Declaration] -> [Declaration]
irredS gE ds = map (foldr1 lub) (eqClass order ds)
               where m `lub` m'   = if a `gE` b && a' `gE` b' then m else m'
                                    where (a,a') = sign m; (b,b') = sign m'
                     m `order` m' = (a `gE` b && a' `gE` b') || (b `gE` a && b' `gE` a')
                                    where (a,a') = sign m; (b,b') = sign m'
irredM :: Morphic a => GenR -> [a] -> [a]
irredM gE as = map (foldr1 lub) (eqClass order as)
               where m `lub` m'   = if a `gE` b && a' `gE` b' then m else m'
                                    where (a,a') = sign m; (b,b') = sign m'
                     m `order` m' = (a `gE` b && a' `gE` b') || (b `gE` a && b' `gE` a')
                                    where (a,a') = sign m; (b,b') = sign m'

renumber ss = [ Sgn nm a b props prL prM prR cs expla pos nr sig | (nr,Sgn nm a b props prL prM prR cs expla pos _ sig)<-zip [1..] ss]
mergecontents ss = [ Sgn nm a b (rd [p|s<-cl,p<-multiplicities s])
                                prL prM prR
                                (sord [l|s<-cl,l<-contents s])
                                expla p nr sig
                   | (nr,cl)<-zip [1..] (eqClass (==) ss)
                   , Sgn nm a b props prL prM prR cs expla p _ sig <-
                       take 1 ([s|s@(Sgn _ _ _ _ prL prM prR _ _ _ _ _)<-cl
                                 , not (null (prL++prM++prR))]++cl)
                   ]

deriveMults ks sgs
 = error "TODO DeriveMults moet ook multipliciteiten van relaties afleiden van expressies."++
   [Sgn nm a b (props `uni` derived s) prL prM prR cs expla pos nr sig| s@(Sgn nm a b props prL prM prR cs expla pos nr sig)<-sgs]
   where derived s = []

subExprCheck r@(Ru c antc p cons cpu expla sgn nr pn)
 = (Ru c antc p cons matches expla sgn nr pn
   , if not (null cerrs) then [showADL r++"\n"++"COMPUTING not allowed for closures (neither * nor +)."] else
     [ 
       if length es>1
       then "cannot decide which occurrence of ("++showADL c++") you mean:\n"++chain "\n" [showADL e++"["++show (source e)++"*"++show (target e)++"]"| e<-es]
       else "No match found for " ++showADL c++" in this rule."
     | (c,es)<-cpu']
   )
   where
    (matches,str) = recur ([antc|c/='A']++[cons])
    cerrs = [] -- obsolete? map (drop 5) ([ name m| m<-mors r] `isc` map (("Clos_"++).name.head.mors.fst) cpu')
    cpu'  = [ (c,es) | c<-cpu, es<-[rd[m| m<-matches, c `match` m]], length es/=1]
    recur  []    = ([],"")
    recur (e:es) = (subexps++matches , "   recur "++showADL (e:es)++" = "++showADL (subexps++matches)++"\nbecause\n"++
                   "("++showADL subexps++" = subexprs ("++showADL e++") and\n"++
                   "("++showADL matches++" = recur ("++showADL es++")\n--------\n"++str'++str'')
     where (subexps,str')  = subexprs e
           (matches,str'') = recur es
    subexprs e@(Tm m)    = ([e| c<-cpu, e `match` c] , "")
    subexprs e@(Tc e')   = subexprs e'
    subexprs e@(F ts)    = ([e| c<-cpu, e `match` c]++matches ,  showADL matches++" = recur ("++showADL ts++")\n--------\n"++str)
                           where (matches,str) = recur ts
    subexprs e@(Fd ts)   = ([e| c<-cpu, e `match` c]++matches ,  showADL matches++" = recur ("++showADL ts++")\n--------\n"++str)
                           where (matches,str) = recur ts
    subexprs e@(Fi fs)   = ([e| c<-cpu, e `match` c]++matches ,  showADL matches++" = recur ("++showADL fs++")\n--------\n"++str)
                           where (matches,str) = recur fs
    subexprs e@(Fu fs)   = ([e| c<-cpu, e `match` c]++matches ,  showADL matches++" = recur ("++showADL fs++")\n--------\n"++str)
                           where (matches,str) = recur fs
    subexprs e@(K0 e')   = ([e| c<-cpu, e `match` c]++matches ,  showADL matches++" = subexprs ("++showADL e'++")\n--------\n"++str)
                           where (matches,str) = subexprs e'
    subexprs e@(K1 e')   = ([e| c<-cpu, e `match` c]++matches ,  showADL matches++" = subexprs ("++showADL e'++")\n--------\n"++str)
                           where (matches,str) = subexprs e'
    subexprs e@(Cp e')   = ([e| c<-cpu, e `match` c]++matches ,  showADL matches++" = subexprs ("++showADL e'++")\n--------\n"++str)
                           where (matches,str) = subexprs e'
    match  (Tm m) (Tm m')  = name m == name m' && (sign m `order` sign m' || sign (flp m) `order` sign m')
    match  (F ts) (F ts')  = length ms==length ms' && and [f `match` f'| (f,f')<-zip ms ms']
                             where ms = filter isMph ts; ms' = filter isMph ts'
    match (Fd ts) (Fd ts') = length ms==length ms' && and [f `match` f'| (f,f')<-zip ms ms']
                             where ms = filter isMph ts; ms' = filter isMph ts'
    match (Fi fs) (Fi fs') = and [f `match` f'|(f,f')<-zip fs fs'] -- or [ and [f `match` f'|(f,f')<-zip fs prm] | prm<-perms fs']
    match (Fu fs) (Fu fs') = and [f `match` f'|(f,f')<-zip fs fs'] -- or [ and [f `match` f'|(f,f')<-zip fs prm] | prm<-perms fs']
    match  (K0 e) (K0 e')  = e `match` e'
    match  (K1 e) (K1 e')  = e `match` e'
    match  (Cp e) (Cp e')  = e `match` e'
    match  (Tc e) e'       = match e e'
    match  e (Tc e')       = match e e'
    match _ _              = False

llub gE ss ss'
 = if null ss'
   then if null ss
        then []
        else ss
   else if null ss
        then ss'
        else rd [ (if a `gE` a' then a' else a, if b `gE` b' then b' else b)
                | (a,b)<-ss, (a',b')<-ss'
                , (a `gE` a' || a' `gE` a) && (b `gE` b' || b' `gE` b)
                ]
tlub gE cs [] = []
tlub gE [] cs = []
tlub gE as bs = (map (foldr1 lub) . eqClass order) [lub a b| a<-as, b<-bs, a `order` b]
                where lub a b = if a `gE` b then b else a
                      order a b = a `gE` b || b `gE` a
-- comp is bedoeld voor de typering van alle mogelijkheden bij een ;. Alle mogelijke types van l worden gematcht met alle mogelijke types van r, om alle mogelijke types van l;r te verkrijgen.
comp gE ls rs = [(f a a' b,f b' a' b)|(a,b)<-ls, (a',b')<-rs, a' `gE` b || b `gE` a']
                where f Anything x y | x `gE` y = y
                                     | y `gE` x = x
                      f a _ _ = a
comps gE tss  = if null ss then [] else foldr1 (comp gE) ss
                where ss=[s|s<-tss, not (null s)]
distr pos (a,b) gE css [t] = map Tm (ids gE a (source t))++[t]++map Tm (ids gE (target t) b)
distr pos (a,b) gE css ts
 = if or [length cs>1|cs<-css]
   then error ("Fatal: ambiguities "++show css)
   else concat [map Tm (ids gE x (source t))++[t|not (eq t)]| (x,y,t)<-zip3 ([a]++cs) (cs++[b]) ts]++map Tm (ids gE (target (last ts)) b)
   where cs  = [c|[c]<-css]
         eq :: Expression -> Bool
         eq t = idsOnly t && source t==target t
-- ids creates an identity with source x and target y, but only if necessary (that is: when x and y differ)
ids gE x y | x==y      = []
           | x `gE` y  = [I [] x y False]
           | otherwise = [I [] y x True]
-- Architecture ------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      cs                   : Contexts
      sErr                 : [String]

-}
{-
   local variables for Architecture.Arch:

-}
-- semantic domain
type T_Architecture = ((Contexts),([String]))
-- cata
sem_Architecture :: (Architecture) ->
                    (T_Architecture)
sem_Architecture ((Arch (_cs))) =
    (sem_Architecture_Arch ((sem_Contexts (_cs))))
sem_Architecture_Arch :: (T_Contexts) ->
                         (T_Architecture)
sem_Architecture_Arch (_cs) =
    let ( _cs_contexts,_cs_over,_cs_sErr) =
            (_cs (_cs_over))
    in  (_cs_contexts,_cs_sErr)
-- Concept -----------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR

   chained attributes:

   synthesised attributes:
      concept              : Concept
      nm                   : String

-}
{-
   local variables for Concept.Anything:

-}
{-
   local variables for Concept.C:

-}
{-
   local variables for Concept.NOthing:

-}
{-
   local variables for Concept.S:

-}
-- semantic domain
type T_Concept = (GenR) ->
                 ((Concept),(String))
-- cata
sem_Concept :: (Concept) ->
               (T_Concept)
sem_Concept ((Anything )) =
    (sem_Concept_Anything )
sem_Concept ((C (_c) (_gE) (_os))) =
    (sem_Concept_C (_c) (_gE) (_os))
sem_Concept ((NOthing )) =
    (sem_Concept_NOthing )
sem_Concept ((S (_c) (_gE) (_os))) =
    (sem_Concept_S (_c) (_gE) (_os))
sem_Concept_Anything :: (T_Concept)
sem_Concept_Anything (_lhs_gE) =
    let 
    in  (Anything,"Anything")
sem_Concept_C :: (String) ->
                 (GenR) ->
                 ([String]) ->
                 (T_Concept)
sem_Concept_C (_c) (_gE) (_os) (_lhs_gE) =
    let 
    in  (C _c _lhs_gE [],_c)
sem_Concept_NOthing :: (T_Concept)
sem_Concept_NOthing (_lhs_gE) =
    let 
    in  (NOthing,"NOthing")
sem_Concept_S :: (String) ->
                 (GenR) ->
                 ([String]) ->
                 (T_Concept)
sem_Concept_S (_c) (_gE) (_os) (_lhs_gE) =
    let 
    in  (S _c _lhs_gE [],_c)
-- ConceptDef --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      c                    : ConceptDef

-}
{-
   local variables for ConceptDef.Cd:

-}
-- semantic domain
type T_ConceptDef = ((ConceptDef))
-- cata
sem_ConceptDef :: (ConceptDef) ->
                  (T_ConceptDef)
sem_ConceptDef ((Cd (_pos) (_nm) (_def) (_ref))) =
    (sem_ConceptDef_Cd (_pos) (_nm) (_def) (_ref))
sem_ConceptDef_Cd :: (FilePos) ->
                     (String) ->
                     (String) ->
                     (String) ->
                     (T_ConceptDef)
sem_ConceptDef_Cd (_pos) (_nm) (_def) (_ref) =
    let 
    in  (Cd _pos _nm _def _ref)
-- ConceptDefs -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      conDefs              : [ConceptDef]

-}
{-
   local variables for ConceptDefs.Cons:

-}
{-
   local variables for ConceptDefs.Nil:

-}
-- semantic domain
type T_ConceptDefs = (([ConceptDef]))
-- cata
sem_ConceptDefs :: (ConceptDefs) ->
                   (T_ConceptDefs)
sem_ConceptDefs (list) =
    (foldr (sem_ConceptDefs_Cons) (sem_ConceptDefs_Nil) ((map sem_ConceptDef list)))
sem_ConceptDefs_Cons :: (T_ConceptDef) ->
                        (T_ConceptDefs) ->
                        (T_ConceptDefs)
sem_ConceptDefs_Cons (_hd) (_tl) =
    let ( _hd_c) =
            (_hd )
        ( _tl_conDefs) =
            (_tl )
    in  (_hd_c : _tl_conDefs)
sem_ConceptDefs_Nil :: (T_ConceptDefs)
sem_ConceptDefs_Nil  =
    let 
    in  ([])
-- Concepts ----------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Concepts.Cons:

-}
{-
   local variables for Concepts.Nil:

-}
-- semantic domain
type T_Concepts = (GenR) ->
                  ()
-- cata
sem_Concepts :: (Concepts) ->
                (T_Concepts)
sem_Concepts (list) =
    (foldr (sem_Concepts_Cons) (sem_Concepts_Nil) ((map sem_Concept list)))
sem_Concepts_Cons :: (T_Concept) ->
                     (T_Concepts) ->
                     (T_Concepts)
sem_Concepts_Cons (_hd) (_tl) (_lhs_gE) =
    let ( _hd_concept,_hd_nm) =
            (_hd (_lhs_gE))
    in  ()
sem_Concepts_Nil :: (T_Concepts)
sem_Concepts_Nil (_lhs_gE) =
    let 
    in  ()
-- Context -----------------------------------------------------
{-
   inherited attributes:
      ctxTree              : Classification (Context,(Gens,Declarations))
      ctxs                 : [(Context,(Gens,Declarations))]

   chained attributes:

   synthesised attributes:
      context              : Context
      nRules               : Int
      over                 : [(Context,(Gens,Declarations))]
      rules                : Rules
      sErr                 : [String]

-}
{-
   local variables for Context.Ctx:
      cD
      genE
      inh
      mGen
      keys
      mC
      mD

-}
-- semantic domain
type T_Context = (Classification (Context,(Gens,Declarations))) ->
                 ([(Context,(Gens,Declarations))]) ->
                 ((Context),(Int),([(Context,(Gens,Declarations))]),(Rules),([String]))
-- cata
sem_Context :: (Context) ->
               (T_Context)
sem_Context ((Ctx (_nm) (_on) (_isa) (_world) (_dc) (_ds) (_cs) (_ks) (_os) (_pops))) =
    (sem_Context_Ctx (_nm) (_on) (_isa) (_world) ((sem_Patterns (_dc))) ((sem_Declarations (_ds))) ((sem_ConceptDefs (_cs))) ((sem_KeyDefs (_ks))) ((sem_ObjDefs (_os))) ((sem_Populations (_pops))))
sem_Context_Ctx :: (String) ->
                   ([String]) ->
                   (Inheritance Concept) ->
                   ([Classification Context]) ->
                   (T_Patterns) ->
                   (T_Declarations) ->
                   (T_ConceptDefs) ->
                   (T_KeyDefs) ->
                   (T_ObjDefs) ->
                   (T_Populations) ->
                   (T_Context)
sem_Context_Ctx (_nm) (_on) (_isa) (_world) (_dc) (_ds) (_cs) (_ks) (_os) (_pops) (_lhs_ctxTree) (_lhs_ctxs) =
    let (_mD) =
            (                       renumber.mergecontents.concat) [mD| (context,(mG,mD)) <- preCl _lhs_ctxTree]
        (_mC) =
            mergecontents(_ds_rawDecls ++ _dc_rawDecls)
        (_keys) =
            rd (_ks_keyDefs ++ _dc_keyDefs)
        (_mGen) =
            (rd.concat) [mG| (context,(mG,mD)) <- preCl _lhs_ctxTree]
        (_inh) =
            Isa [(g,s)|G pos g s<- _mGen] (concs _mD>-rd [c|G pos g s<- _mGen, c<-[g,s]])
        (_genE) =
            cmp where cmp Anything b = True
                      cmp a Anything = False
                      cmp NOthing b  = False
                      cmp a NOthing  = True
                      cmp a b        = if a==b then True else genEq (typology _inh) a b
        (_cD) =
            makeConceptSpace _genE _dc_morphisms
        ( _dc_conDefs,_dc_keyDefs,_dc_mGen,_dc_morphisms,_dc_patterns,_dc_rawDecls,_dc_rnr,_dc_rules,_dc_sErr,_dc_usedDecls) =
            (_dc (_genE) (1) (_mD))
        ( _ds_declarations,_ds_rawDecls,_ds_rnr,_ds_rules,_ds_sErr) =
            (_ds (_genE) (_os_rnr) (_mD))
        ( _cs_conDefs) =
            (_cs )
        ( _ks_exprs,_ks_keyDefs,_ks_rnr,_ks_rules,_ks_sErr) =
            (_ks (_genE) (_ds_rnr) (_mD))
        ( _os_objDefs,_os_rnr,_os_rules,_os_sErr,_os_sources) =
            (_os (_genE) ([Anything]) (_dc_rnr) (_mD))
        ( _pops_popus,_pops_sErr) =
            (_pops (_genE) (_mD))
    in  (put_gE _genE _cD
         ( Ctx _nm
               _on
               _inh
               [cl|Cl r cls<-[mapCl fst _lhs_ctxTree], cl<-cls]
               _dc_patterns
               (declarations _dc_patterns)
               (sort' name (rd (_cs_conDefs ++ _dc_conDefs)))
               _keys
               _os_objDefs
               _pops_popus)
        ,_ks_rnr-1
        ,[( put_gE _genE _cD (Ctx _nm _on _inh [] _dc_patterns _mC _cs_conDefs _keys _os_objDefs _pops_popus)
         , (_dc_mGen, _mC))]
        ,_dc_rules ++ _os_rules ++ _ds_rules ++ _ks_rules
        ,_dc_sErr ++ _ks_sErr ++ _os_sErr ++ _pops_sErr
        )
-- Contexts ----------------------------------------------------
{-
   inherited attributes:
      ctxs                 : [(Context,(Gens,Declarations))]

   chained attributes:

   synthesised attributes:
      contexts             : Contexts
      over                 : [(Context,(Gens,Declarations))]
      sErr                 : [String]

-}
{-
   local variables for Contexts.Cons:

-}
{-
   local variables for Contexts.Nil:

-}
-- semantic domain
type T_Contexts = ([(Context,(Gens,Declarations))]) ->
                  ((Contexts),([(Context,(Gens,Declarations))]),([String]))
-- cata
sem_Contexts :: (Contexts) ->
                (T_Contexts)
sem_Contexts (list) =
    (foldr (sem_Contexts_Cons) (sem_Contexts_Nil) ((map sem_Context list)))
sem_Contexts_Cons :: (T_Context) ->
                     (T_Contexts) ->
                     (T_Contexts)
sem_Contexts_Cons (_hd) (_tl) (_lhs_ctxs) =
    let ( _hd_context,_hd_nRules,_hd_over,_hd_rules,_hd_sErr) =
            (_hd (mkCtxAG _lhs_ctxs (name _hd_context)) (_lhs_ctxs))
        ( _tl_contexts,_tl_over,_tl_sErr) =
            (_tl (_lhs_ctxs))
    in  (_hd_context : _tl_contexts,_hd_over ++ _tl_over,_hd_sErr ++ _tl_sErr)
sem_Contexts_Nil :: (T_Contexts)
sem_Contexts_Nil (_lhs_ctxs) =
    let 
    in  ([],[],[])
-- Declaration -------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      declaration          : Declaration
      nm                   : String
      rawDecl              : Declaration
      rules                : Rules
      sErr                 : [String]

-}
{-
   local variables for Declaration.Iscompl:

-}
{-
   local variables for Declaration.Isn:

-}
{-
   local variables for Declaration.Sgn:
      msignat

-}
{-
   local variables for Declaration.Vs:

-}
-- semantic domain
type T_Declaration = (GenR) ->
                     (Int) ->
                     (Declarations) ->
                     ((Declaration),(String),(Declaration),(Int),(Rules),([String]))
-- cata
sem_Declaration :: (Declaration) ->
                   (T_Declaration)
sem_Declaration ((Iscompl (_g) (_s))) =
    (sem_Declaration_Iscompl ((sem_Concept (_g))) ((sem_Concept (_s))))
sem_Declaration ((Isn (_g) (_s))) =
    (sem_Declaration_Isn ((sem_Concept (_g))) ((sem_Concept (_s))))
sem_Declaration ((Sgn (_nm) (_a) (_b) (_props) (_prL) (_prM) (_prR) (_content) (_expla) (_morPos) (_nr) (_sig))) =
    (sem_Declaration_Sgn (_nm) ((sem_Concept (_a))) ((sem_Concept (_b))) (_props) (_prL) (_prM) (_prR) (_content) (_expla) (_morPos) (_nr) (_sig))
sem_Declaration ((Vs (_g) (_s))) =
    (sem_Declaration_Vs ((sem_Concept (_g))) ((sem_Concept (_s))))
sem_Declaration_Iscompl :: (T_Concept) ->
                           (T_Concept) ->
                           (T_Declaration)
sem_Declaration_Iscompl (_g) (_s) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let ( _g_concept,_g_nm) =
            (_g (_lhs_gE))
        ( _s_concept,_s_nm) =
            (_s (_lhs_gE))
    in  (Iscompl _g_concept _s_concept,"I",Iscompl _g_concept _s_concept,_lhs_rnr,[],[])
sem_Declaration_Isn :: (T_Concept) ->
                       (T_Concept) ->
                       (T_Declaration)
sem_Declaration_Isn (_g) (_s) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let ( _g_concept,_g_nm) =
            (_g (_lhs_gE))
        ( _s_concept,_s_nm) =
            (_s (_lhs_gE))
    in  (Isn _g_concept _s_concept,"I",Isn _g_concept _s_concept,_lhs_rnr,[],[])
sem_Declaration_Sgn :: (String) ->
                       (T_Concept) ->
                       (T_Concept) ->
                       ([Prop]) ->
                       (String) ->
                       (String) ->
                       (String) ->
                       ([Paire]) ->
                       (String) ->
                       (FilePos) ->
                       (Int) ->
                       (Bool) ->
                       (T_Declaration)
sem_Declaration_Sgn (_nm) (_a) (_b) (_props) (_prL) (_prM) (_prR) (_content) (_expla) (_morPos) (_nr) (_sig) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let (_msignat) =
            head ([ s
                  | s <- _lhs_sDef, _nm==name s, _a_concept==source s, _b_concept==target s]++
                  [error ("Missing "++showHS "" (Sgn _nm _a_concept _b_concept _props _prL _prM _prR _content _expla _morPos 0 _sig)++" in AGtry.ag\n"++ show _lhs_sDef)])
        ( _a_concept,_a_nm) =
            (_a (_lhs_gE))
        ( _b_concept,_b_nm) =
            (_b (_lhs_gE))
    in  (_msignat
        ,_nm
        ,Sgn _nm _a_concept _b_concept _props _prL _prM _prR _content _expla _morPos 0 _sig
        ,_lhs_rnr + length (multRules _msignat)
        ,renumberRules _lhs_rnr (multRules _msignat)
        ,if _a_nm == _b_nm then [] else
         let ps = _props `isc` [Trn,Rfx,Sym,Asy] in
         if null ps then []
         else ["7 in "++show _morPos++"\n   Heterogeneous relation "++
               _nm++"["++ _a_nm ++"*"++ _b_nm ++
               "]\n   may not be declared "++commaEng "and" [pMeaning p| p<-ps]++
               ".\n   (This relation is heterogeneous because "++ _a_nm ++" and "++ _b_nm ++
               "\n   are different concepts).\n"]
        )
sem_Declaration_Vs :: (T_Concept) ->
                      (T_Concept) ->
                      (T_Declaration)
sem_Declaration_Vs (_g) (_s) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let ( _g_concept,_g_nm) =
            (_g (_lhs_gE))
        ( _s_concept,_s_nm) =
            (_s (_lhs_gE))
    in  (Vs _g_concept _s_concept,"V",Vs _g_concept _s_concept,_lhs_rnr,[],[])
-- Declarations ------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      declarations         : Declarations
      rawDecls             : Declarations
      rules                : Rules
      sErr                 : [String]

-}
{-
   local variables for Declarations.Cons:

-}
{-
   local variables for Declarations.Nil:

-}
-- semantic domain
type T_Declarations = (GenR) ->
                      (Int) ->
                      (Declarations) ->
                      ((Declarations),(Declarations),(Int),(Rules),([String]))
-- cata
sem_Declarations :: (Declarations) ->
                    (T_Declarations)
sem_Declarations (list) =
    (foldr (sem_Declarations_Cons) (sem_Declarations_Nil) ((map sem_Declaration list)))
sem_Declarations_Cons :: (T_Declaration) ->
                         (T_Declarations) ->
                         (T_Declarations)
sem_Declarations_Cons (_hd) (_tl) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let ( _hd_declaration,_hd_nm,_hd_rawDecl,_hd_rnr,_hd_rules,_hd_sErr) =
            (_hd (_lhs_gE) (_lhs_rnr) (_lhs_sDef))
        ( _tl_declarations,_tl_rawDecls,_tl_rnr,_tl_rules,_tl_sErr) =
            (_tl (_lhs_gE) (_hd_rnr) (_lhs_sDef))
    in  (_hd_declaration: _tl_declarations,_hd_rawDecl: _tl_rawDecls,_tl_rnr,_hd_rules ++ _tl_rules,_hd_sErr ++ _tl_sErr)
sem_Declarations_Nil :: (T_Declarations)
sem_Declarations_Nil (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let 
    in  ([],[],_lhs_rnr,[],[])
-- Expression --------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      isign                : [(Concept,Concept)]
      pn                   : String
      pos                  : FilePos
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      expr                 : Expression
      morphisms            : Morphisms
      raw                  : Expression
      rules                : Rules
      sErr                 : [String]
      signs                : [(Concept,Concept)]

-}
{-
   local variables for Expression.Cp:

-}
{-
   local variables for Expression.F:
      dis
      trpls
      sgns

-}
{-
   local variables for Expression.Fd:
      dis
      trpls
      sgns

-}
{-
   local variables for Expression.Fi:
      dis
      sgns

-}
{-
   local variables for Expression.Fu:
      dis
      sgns

-}
{-
   local variables for Expression.K0:
      closmor

-}
{-
   local variables for Expression.K1:
      closmor

-}
{-
   local variables for Expression.Tc:

-}
{-
   local variables for Expression.Tm:

-}
-- semantic domain
type T_Expression = (GenR) ->
                    ([(Concept,Concept)]) ->
                    (String) ->
                    (FilePos) ->
                    (Int) ->
                    (Declarations) ->
                    ((Expression),(Morphisms),(Expression),(Int),(Rules),([String]),([(Concept,Concept)]))
-- cata
sem_Expression :: (Expression) ->
                  (T_Expression)
sem_Expression ((Cp (_e))) =
    (sem_Expression_Cp ((sem_Expression (_e))))
sem_Expression ((F (_ts))) =
    (sem_Expression_F ((sem_Expressions (_ts))))
sem_Expression ((Fd (_ts))) =
    (sem_Expression_Fd ((sem_Expressions (_ts))))
sem_Expression ((Fi (_fs))) =
    (sem_Expression_Fi ((sem_Expressions (_fs))))
sem_Expression ((Fu (_fs))) =
    (sem_Expression_Fu ((sem_Expressions (_fs))))
sem_Expression ((K0 (_e))) =
    (sem_Expression_K0 ((sem_Expression (_e))))
sem_Expression ((K1 (_e))) =
    (sem_Expression_K1 ((sem_Expression (_e))))
sem_Expression ((Tc (_c))) =
    (sem_Expression_Tc ((sem_Expression (_c))))
sem_Expression ((Tm (_m))) =
    (sem_Expression_Tm ((sem_Morphism (_m))))
sem_Expression_Cp :: (T_Expression) ->
                     (T_Expression)
sem_Expression_Cp (_e) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let ( _e_expr,_e_morphisms,_e_raw,_e_rnr,_e_rules,_e_sErr,_e_signs) =
            (_e (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef))
    in  (Cp _e_expr,_e_morphisms,Cp _e_raw,_e_rnr,_e_rules,_e_sErr,_e_signs)
sem_Expression_F :: (T_Expressions) ->
                    (T_Expression)
sem_Expression_F (_ts) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let (_sgns) =
            comps _lhs_gE _ts_signss
        (_trpls) =
            if null _sgns
            then [ (head (irredC _lhs_gE [s| (s,t)<-sl]),l,sl,tlub _lhs_gE (rd(map snd sl)) (rd(map fst sr)),sr,r,head (irredC _lhs_gE [t| (s,t)<-sr]))
                 | ((l,r),(sls,srs))<-zip (chop _ts_exprs) (chop _ts_signss)
                 , sl <- [comps _lhs_gE sls], not (null sl)
                 , sr <- [comps _lhs_gE srs], not (null sr)
                 ]
            else [ (a,l,sl,tlub _lhs_gE (rd(map snd sl)) (rd(map fst sr)),sr,r,b)
                 | (a,b) <- take 1 _lhs_isign
                 , ((l,r),(sls,srs))<-zip (chop _ts_exprs) (chop _ts_signss)
                 , sl <- [[(s,t)| (s,t)<-comps _lhs_gE sls,if a/=Anything then s `_lhs_gE` a else True]]
                 , sr <- [[(s,t)| (s,t)<-comps _lhs_gE srs,if b/=Anything then t `_lhs_gE` b else True]]
                 ]
        (_dis) =
            if null _lhs_isign then F (_ts_exprs) else
            let (s,t)= head _lhs_isign
            in F (
                  distr _lhs_pos (s,t) _lhs_gE [cs|(a,l,sl,cs,sr,r,b)<- _trpls, s `_lhs_gE` a, t `_lhs_gE` b] _ts_exprs)
        ( _ts_exprs,_ts_morphisms,_ts_raw,_ts_rnr,_ts_rules,_ts_sErr,_ts_signss) =
            (_ts (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) (_trpls))
    in  (_dis
        ,_ts_morphisms
        ,F _ts_raw
        ,_ts_rnr
        ,_ts_rules
        ,_ts_sErr++
         [ "5 in "++show _lhs_pos++"\n   Type error in composing\n   "++
           chain " and\n   " [show l++" :: "++shSigns sgnsl++" with "++show r++" :: "++shSigns sgnsr
                         | (l,sgnsl,r,sgnsr)<-errs]++"\n"
         | errs<- [[(l,sgnsl,r,sgnsr) | ((sgnsl,sgnsr),(l,r))<- zip (zip _ts_signss (tail _ts_signss)) (zip _ts_raw (tail _ts_raw))
                                      , correct<-[[(sl,tl,sr,tr)|(sl,tl)<-sgnsl, (sr,tr)<-sgnsr, tl `order` sr || anything tl || anything sr]]
                                      , null correct]]
         , not (null errs)
         ]++                      [ "6 in "++show _lhs_pos++"\n   Ambiguous composition over concepts "++show cs++" of\n   "++
           show (F ls)++" :: "++shSigns sl++
           " and\n   "++
           show (F rs)++" :: "++shSigns sr++"\n"
         |(a,ls,sl,cs,sr,rs,b)<- _trpls, length cs>1]
        ,_sgns
        )
sem_Expression_Fd :: (T_Expressions) ->
                     (T_Expression)
sem_Expression_Fd (_ts) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let (_sgns) =
            comps _lhs_gE _ts_signss
        (_trpls) =
            if null _sgns
            then [ (head (irredC _lhs_gE [s| (s,t)<-sl]),l,sl,tlub _lhs_gE (rd(map snd sl)) (rd(map fst sr)),sr,r,head (irredC _lhs_gE [t| (s,t)<-sr]))
                 | ((l,r),(sls,srs))<-zip (chop _ts_exprs) (chop _ts_signss)
                 , sl <- [comps _lhs_gE sls], not (null sl)
                 , sr <- [comps _lhs_gE srs], not (null sr)
                 ]
            else [ (a,l,sl,tlub _lhs_gE (rd(map snd sl)) (rd(map fst sr)),sr,r,b)
                 | (a,b) <- take 1 _lhs_isign
                 , ((l,r),(sls,srs))<-zip (chop _ts_exprs) (chop _ts_signss)
                 , sl <- [[(s,t)| (s,t)<-comps _lhs_gE sls,if a/=Anything then s `_lhs_gE` a else True]]
                 , sr <- [[(s,t)| (s,t)<-comps _lhs_gE srs,if b/=Anything then t `_lhs_gE` b else True]]
                 ]
        (_dis) =
            if null _lhs_isign then Fd (_ts_exprs) else
            let (s,t)= head _lhs_isign
            in Fd (
                   distr _lhs_pos (s,t) _lhs_gE [cs|(a,l,sl,cs,sr,r,b)<- _trpls, a==s, b==t] _ts_exprs)
        ( _ts_exprs,_ts_morphisms,_ts_raw,_ts_rnr,_ts_rules,_ts_sErr,_ts_signss) =
            (_ts (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) (_trpls))
    in  (_dis
        ,_ts_morphisms
        ,Fd _ts_raw
        ,_ts_rnr
        ,_ts_rules
        ,_ts_sErr++
         [ "5 in "++show _lhs_pos++"\n   Type error in composing\n   "++
           chain " and\n   " [show l++" :: "++shSigns sgnsl++" with "++show r++" :: "++shSigns sgnsr
                         | (l,sgnsl,r,sgnsr)<-errs]
         | errs<- [[(l,sgnsl,r,sgnsr) | ((sgnsl,sgnsr),(l,r))<- zip (zip _ts_signss (tail _ts_signss)) (zip _ts_raw (tail _ts_raw))
                                      , correct<-[[(sl,tl,sr,tr)|(sl,tl)<-sgnsl, (sr,tr)<-sgnsr, tl `order` sr || anything tl || anything sr]]
                                      , null correct]]
         , not (null errs)
         ]++
         [ "6 in "++show _lhs_pos++"\n   Ambiguous relative addition over concepts "++show cs++" of\n   "++
           show (Fd ls)++" :: "++shSigns sl++
           " and\n   "++
           show (Fd rs)++" :: "++shSigns sr++"\n"
         |(a,ls,sl,cs,sr,rs,b)<- _trpls, length cs>1]
        ,_sgns
        )
sem_Expression_Fi :: (T_Expressions) ->
                     (T_Expression)
sem_Expression_Fi (_fs) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let (_sgns) =
            if null _fs_signss then error("Fatal: empty @fs.signss in expression "++showHS "" (Fi _fs_exprs)) else
            foldr1 (llub _lhs_gE) _fs_signss
        (_dis) =
            let [(a,b)] = take 1 _lhs_isign
                (a',b') = (source (head _fs_exprs), target (last _fs_exprs))
            in Fi (                                    _fs_exprs                                    )
        ( _fs_exprs,_fs_morphisms,_fs_raw,_fs_rnr,_fs_rules,_fs_sErr,_fs_signss) =
            (_fs (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) ([]))
    in  (Fi _fs_exprs
        ,_fs_morphisms
        ,Fi _fs_raw
        ,_fs_rnr
        ,_fs_rules
        ,if null _sgns
         then ["4 in "++show _lhs_pos++"\n   Incompatible types in comparing\n   "++
               commaEng "with\n  " [show f++" :: "++shSigns s| (f,s)<-zip _fs_raw _fs_signss]++"\n"]
         else _fs_sErr
        ,if null _sgns then error("Fatal: empty @sgns in Fi-expression "++showADL (Fi _fs_raw)) else _sgns
        )
sem_Expression_Fu :: (T_Expressions) ->
                     (T_Expression)
sem_Expression_Fu (_fs) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let (_sgns) =
            if null _fs_signss then error("Fatal: empty @fs.signss in expression "++showHS "" (Fu _fs_exprs)) else
            foldr1 (llub _lhs_gE) _fs_signss
        (_dis) =
            let [(a,b)] = take 1 _lhs_isign
                (a',b') = (source (head _fs_exprs), target (last _fs_exprs))
            in Fu (                                    _fs_exprs                                    )
        ( _fs_exprs,_fs_morphisms,_fs_raw,_fs_rnr,_fs_rules,_fs_sErr,_fs_signss) =
            (_fs (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) ([]))
    in  (Fu _fs_exprs
        ,_fs_morphisms
        ,Fu _fs_raw
        ,_fs_rnr
        ,_fs_rules
        ,if null _sgns
         then ["4 in "++show _lhs_pos++"\n   Incompatible types in comparing\n   "++
               commaEng "with\n  " [show f++" :: "++shSigns s| (f,s)<-zip _fs_raw _fs_signss]++"\n"]
         else _fs_sErr
        ,if null _sgns then error("Fatal: empty @sgns in Fu-expression "++showADL (Fi _fs_raw)) else _sgns
        )
sem_Expression_K0 :: (T_Expression) ->
                     (T_Expression)
sem_Expression_K0 (_e) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let (_closmor) =
            let [(a,b)] = take 1 _lhs_isign
            in Mph (             (name.head.declarations) _e_expr) _lhs_pos [] (a,b) True (Sgn (             (name.head.declarations) _e_expr) a b [Trn,Rfx] "" "" "" [] "Closure" _lhs_pos 0 True)
        ( _e_expr,_e_morphisms,_e_raw,_e_rnr,_e_rules,_e_sErr,_e_signs) =
            (_e (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr+1) (_lhs_sDef))
    in  (Tm _closmor
        ,_e_morphisms
        ,K0 _e_raw
        ,_e_rnr
        ,let [(a,b)] = take 1 _lhs_isign
         in Ru 'E'
               (Tm _closmor)
               _lhs_pos
               (K0 _e_expr)
               [Tm _closmor]
               ""
               (a,b)
               _lhs_rnr
               _lhs_pn
            : _e_rules
        ,_e_sErr
        ,_e_signs
        )
sem_Expression_K1 :: (T_Expression) ->
                     (T_Expression)
sem_Expression_K1 (_e) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let (_closmor) =
            let [(a,b)] = take 1 _lhs_isign
            in Mph (             (name.head.declarations) _e_expr) _lhs_pos [] (a,b) True (Sgn (             (name.head.declarations) _e_expr) a b [Trn] "" "" "" [] "Closure" _lhs_pos 0 False)
        ( _e_expr,_e_morphisms,_e_raw,_e_rnr,_e_rules,_e_sErr,_e_signs) =
            (_e (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr+1) (_lhs_sDef))
    in  (Tm _closmor
        ,_e_morphisms
        ,K1 _e_raw
        ,_e_rnr
        ,let [(a,b)] = take 1 _lhs_isign
         in Ru 'E'
               (Tm _closmor)
               _lhs_pos
               (K1 _e_expr)
               [Tm _closmor]
               ""
               (a,b)
               _lhs_rnr
               _lhs_pn
            : _e_rules
        ,_e_sErr
        ,_e_signs
        )
sem_Expression_Tc :: (T_Expression) ->
                     (T_Expression)
sem_Expression_Tc (_c) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let ( _c_expr,_c_morphisms,_c_raw,_c_rnr,_c_rules,_c_sErr,_c_signs) =
            (_c (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef))
    in  (Tc _c_expr,_c_morphisms,Tc _c_raw,_lhs_rnr,_c_rules,_c_sErr,_c_signs)
sem_Expression_Tm :: (T_Morphism) ->
                     (T_Expression)
sem_Expression_Tm (_m) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) =
    let ( _m_atts,_m_id,_m_morphism,_m_nm,_m_pos,_m_raw,_m_sErr,_m_usedDecls,_m_yin) =
            (_m (_lhs_gE) (_lhs_isign) (_lhs_sDef))
    in  (Tm _m_morphism,[_m_morphism],let (m,ss) = _m_raw in Tm m,_lhs_rnr,[],_m_sErr,let (m,ss) = _m_raw in if isMph m then (if inline m then map sign ss else map (sign.flp) ss) else [sign m])
-- Expressions -------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      isign                : [(Concept,Concept)]
      pn                   : String
      pos                  : FilePos
      sDef                 : Declarations
      septets              : [(Concept, Expressions, [(Concept,Concept)], [Concept], [(Concept,Concept)], Expressions, Concept)]

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      exprs                : Expressions
      morphisms            : Morphisms
      raw                  : Expressions
      rules                : Rules
      sErr                 : [String]
      signss               : [[(Concept,Concept)]]

-}
{-
   local variables for Expressions.Cons:
      septs
      hsgn

-}
{-
   local variables for Expressions.Nil:

-}
-- semantic domain
type T_Expressions = (GenR) ->
                     ([(Concept,Concept)]) ->
                     (String) ->
                     (FilePos) ->
                     (Int) ->
                     (Declarations) ->
                     ([(Concept, Expressions, [(Concept,Concept)], [Concept], [(Concept,Concept)], Expressions, Concept)]) ->
                     ((Expressions),(Morphisms),(Expressions),(Int),(Rules),([String]),([[(Concept,Concept)]]))
-- cata
sem_Expressions :: (Expressions) ->
                   (T_Expressions)
sem_Expressions (list) =
    (foldr (sem_Expressions_Cons) (sem_Expressions_Nil) ((map sem_Expression list)))
sem_Expressions_Cons :: (T_Expression) ->
                        (T_Expressions) ->
                        (T_Expressions)
sem_Expressions_Cons (_hd) (_tl) (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) (_lhs_septets) =
    let (_hsgn) =
            [(a,c)| (a,l,sl,cs,sr,r,b)<- _lhs_septets, length l==1, c<-cs]
        (_septs) =
            [ (c',tail l,rd[(c',c)|(a,c)<-sl],cs,sr,r,b)
            | (a,l,sl,cs,sr,r,b)<- _lhs_septets,length l>1,(a',c')<- _hsgn]
        ( _hd_expr,_hd_morphisms,_hd_raw,_hd_rnr,_hd_rules,_hd_sErr,_hd_signs) =
            (_hd (_lhs_gE)
                 (if null _lhs_septets then _lhs_isign else
                  _hsgn)
                 (_lhs_pn)
                 (_lhs_pos)
                 (_lhs_rnr)
                 (_lhs_sDef))
        ( _tl_exprs,_tl_morphisms,_tl_raw,_tl_rnr,_tl_rules,_tl_sErr,_tl_signss) =
            (_tl (_lhs_gE)
                 (if null _lhs_septets then _lhs_isign else
                  [(c,b)| (a,l,sl,cs,sr,r,b)<- _lhs_septets, length l==1, c<-cs])
                 (_lhs_pn)
                 (_lhs_pos)
                 (_hd_rnr)
                 (_lhs_sDef)
                 (_septs))
    in  (_hd_expr : _tl_exprs,_hd_morphisms ++ _tl_morphisms,_hd_raw: _tl_raw,_tl_rnr,_hd_rules ++ _tl_rules,_hd_sErr ++ _tl_sErr,_hd_signs: _tl_signss)
sem_Expressions_Nil :: (T_Expressions)
sem_Expressions_Nil (_lhs_gE) (_lhs_isign) (_lhs_pn) (_lhs_pos) (_lhs_rnr) (_lhs_sDef) (_lhs_septets) =
    let 
    in  ([],[],[],_lhs_rnr,[],[],[])
-- Gen ---------------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      pn                   : String

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      gen                  : Gen
      rules                : Rules

-}
{-
   local variables for Gen.G:

-}
-- semantic domain
type T_Gen = (GenR) ->
             (String) ->
             (Int) ->
             ((Gen),(Int),(Rules))
-- cata
sem_Gen :: (Gen) ->
           (T_Gen)
sem_Gen ((G (_pos) (_genus) (_spec))) =
    (sem_Gen_G (_pos) ((sem_Concept (_genus))) ((sem_Concept (_spec))))
sem_Gen_G :: (FilePos) ->
             (T_Concept) ->
             (T_Concept) ->
             (T_Gen)
sem_Gen_G (_pos) (_genus) (_spec) (_lhs_gE) (_lhs_pn) (_lhs_rnr) =
    let ( _genus_concept,_genus_nm) =
            (_genus (_lhs_gE))
        ( _spec_concept,_spec_nm) =
            (_spec (_lhs_gE))
    in  (G _pos _genus_concept _spec_concept
        ,_lhs_rnr+1
        ,[ Ru 'I'
               (Tm (mIs _spec_concept))
               _pos
               (Tm (mIs _genus_concept))
               [Tm (mIs _spec_concept), Tm (mIs _genus_concept)]
               ""
               (_spec_concept, _genus_concept)
               _lhs_rnr
               _lhs_pn
         ]
        )
-- Gens --------------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      pn                   : String

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      list                 : Gens
      rules                : Rules

-}
{-
   local variables for Gens.Cons:

-}
{-
   local variables for Gens.Nil:

-}
-- semantic domain
type T_Gens = (GenR) ->
              (String) ->
              (Int) ->
              ((Gens),(Int),(Rules))
-- cata
sem_Gens :: (Gens) ->
            (T_Gens)
sem_Gens (list) =
    (foldr (sem_Gens_Cons) (sem_Gens_Nil) ((map sem_Gen list)))
sem_Gens_Cons :: (T_Gen) ->
                 (T_Gens) ->
                 (T_Gens)
sem_Gens_Cons (_hd) (_tl) (_lhs_gE) (_lhs_pn) (_lhs_rnr) =
    let ( _hd_gen,_hd_rnr,_hd_rules) =
            (_hd (_lhs_gE) (_lhs_pn) (_lhs_rnr))
        ( _tl_list,_tl_rnr,_tl_rules) =
            (_tl (_lhs_gE) (_lhs_pn) (_hd_rnr))
    in  (_hd_gen : _tl_list,_tl_rnr,_hd_rules ++ _tl_rules)
sem_Gens_Nil :: (T_Gens)
sem_Gens_Nil (_lhs_gE) (_lhs_pn) (_lhs_rnr) =
    let 
    in  ([],_lhs_rnr,[])
-- KeyDef ------------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      exprs                : Expressions
      kd                   : KeyDef
      rules                : Rules
      sErr                 : [String]

-}
{-
   local variables for KeyDef.Kd:

-}
-- semantic domain
type T_KeyDef = (GenR) ->
                (Int) ->
                (Declarations) ->
                ((Expressions),(KeyDef),(Int),(Rules),([String]))
-- cata
sem_KeyDef :: (KeyDef) ->
              (T_KeyDef)
sem_KeyDef ((Kd (_pos) (_lbl) (_ctx) (_ats))) =
    (sem_KeyDef_Kd (_pos) (_lbl) ((sem_Expression (_ctx))) ((sem_ObjDefs (_ats))))
sem_KeyDef_Kd :: (FilePos) ->
                 (String) ->
                 (T_Expression) ->
                 (T_ObjDefs) ->
                 (T_KeyDef)
sem_KeyDef_Kd (_pos) (_lbl) (_ctx) (_ats) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let ( _ctx_expr,_ctx_morphisms,_ctx_raw,_ctx_rnr,_ctx_rules,_ctx_sErr,_ctx_signs) =
            (_ctx (_lhs_gE) (_ctx_signs) ("") (_pos) (_ats_rnr) (_lhs_sDef))
        ( _ats_objDefs,_ats_rnr,_ats_rules,_ats_sErr,_ats_sources) =
            (_ats (_lhs_gE) (rd (map snd _ctx_signs)) (_lhs_rnr) (_lhs_sDef))
    in  ([ expr | Obj nm pos expr ats <- _ats_objDefs],Kd _pos _lbl _ctx_expr _ats_objDefs,_ctx_rnr,_ats_rules ++ _ctx_rules,_ats_sErr)
-- KeyDefs -----------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      exprs                : Expressions
      keyDefs              : KeyDefs
      rules                : Rules
      sErr                 : [String]

-}
{-
   local variables for KeyDefs.Cons:

-}
{-
   local variables for KeyDefs.Nil:

-}
-- semantic domain
type T_KeyDefs = (GenR) ->
                 (Int) ->
                 (Declarations) ->
                 ((Expressions),(KeyDefs),(Int),(Rules),([String]))
-- cata
sem_KeyDefs :: (KeyDefs) ->
               (T_KeyDefs)
sem_KeyDefs (list) =
    (foldr (sem_KeyDefs_Cons) (sem_KeyDefs_Nil) ((map sem_KeyDef list)))
sem_KeyDefs_Cons :: (T_KeyDef) ->
                    (T_KeyDefs) ->
                    (T_KeyDefs)
sem_KeyDefs_Cons (_hd) (_tl) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let ( _hd_exprs,_hd_kd,_hd_rnr,_hd_rules,_hd_sErr) =
            (_hd (_lhs_gE) (_lhs_rnr) (_lhs_sDef))
        ( _tl_exprs,_tl_keyDefs,_tl_rnr,_tl_rules,_tl_sErr) =
            (_tl (_lhs_gE) (_hd_rnr) (_lhs_sDef))
    in  (_hd_exprs ++ _tl_exprs,_hd_kd : _tl_keyDefs,_tl_rnr,_hd_rules ++ _tl_rules,_hd_sErr ++ _tl_sErr)
sem_KeyDefs_Nil :: (T_KeyDefs)
sem_KeyDefs_Nil (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let 
    in  ([],[],_lhs_rnr,[],[])
-- Morphism ----------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      isign                : [(Concept,Concept)]
      sDef                 : Declarations

   chained attributes:

   synthesised attributes:
      atts                 : [Concept]
      id                   : Bool
      morphism             : Morphism
      nm                   : String
      pos                  : FilePos
      raw                  : (Morphism,Declarations)
      sErr                 : [String]
      usedDecls            : Declarations
      yin                  : Bool

-}
{-
   local variables for Morphism.I:
      ats
      rraw

-}
{-
   local variables for Morphism.Mph:
      ats
      ss
      rel
      m
      s

-}
{-
   local variables for Morphism.V:
      ats
      rraw

-}
-- semantic domain
type T_Morphism = (GenR) ->
                  ([(Concept,Concept)]) ->
                  (Declarations) ->
                  (([Concept]),(Bool),(Morphism),(String),(FilePos),((Morphism,Declarations)),([String]),(Declarations),(Bool))
-- cata
sem_Morphism :: (Morphism) ->
                (T_Morphism)
sem_Morphism ((I (_atts) (_g) (_s) (_yin))) =
    (sem_Morphism_I (_atts) ((sem_Concept (_g))) ((sem_Concept (_s))) (_yin))
sem_Morphism ((Mph (_nm) (_pos) (_atts) (_sgn) (_yin) (_u))) =
    (sem_Morphism_Mph (_nm) (_pos) (_atts) (_sgn) (_yin) ((sem_Declaration (_u))))
sem_Morphism ((V (_atts) (_sgn))) =
    (sem_Morphism_V (_atts) (_sgn))
sem_Morphism_I :: ([Concept]) ->
                  (T_Concept) ->
                  (T_Concept) ->
                  (Bool) ->
                  (T_Morphism)
sem_Morphism_I (_atts) (_g) (_s) (_yin) (_lhs_gE) (_lhs_isign) (_lhs_sDef) =
    let (_rraw) =
            if null _ats      then I [] Anything Anything True  else
            if length _ats==1 then I _ats (head _ats) (head _ats) True              else
            error ("Contact your dealer:\nADL allows only one concept in I["++show _atts++"].")
        (_ats) =
            rd ([C a _lhs_gE as|C a _ as<- _atts]++[S a _lhs_gE as|S a _ as<- _atts])
        ( _g_concept,_g_nm) =
            (_g (_lhs_gE))
        ( _s_concept,_s_nm) =
            (_s (_lhs_gE))
    in  (_ats
        ,True
        ,let (s,t) = if null _lhs_isign && null _ats then error ("Fatal: null @lhs.isign in I lhs.morphism!") else
                     head (_lhs_isign++[(head _ats,last _ats)])
             is = ids _lhs_gE s t
         in if null is then I _ats s t True else head is
        ,"I"
        ,posNone
        ,( _rraw, [])
        ,[]
        ,declarations [ _rraw ]
        ,let I ats g s yin = _rraw in yin
        )
sem_Morphism_Mph :: (String) ->
                    (FilePos) ->
                    ([Concept]) ->
                    ((Concept,Concept)) ->
                    (Bool) ->
                    (T_Declaration) ->
                    (T_Morphism)
sem_Morphism_Mph (_nm) (_pos) (_atts) (_sgn) (_yin) (_u) (_lhs_gE) (_lhs_isign) (_lhs_sDef) =
    let (_s) =
            if null _lhs_isign
            then error("Fatal 2: Empty declaration allocation for "++ _nm ++" on "++show _pos++":\n  @ss="++chain "\n       " (map show _ss))
            else head _lhs_isign
        (_m) =
            if null _rel
            then error("Fatal 3: Empty declaration allocation for "++show _nm++" on "++show _pos++":\n  @lhs.isign="++show _lhs_isign++":\n  @ss="++chain "\n       " (map show _ss))
            else if length _rel>1
            then error("Fatal 6: Ambiguous declaration allocation for "++show _nm++" on "++show _pos++":\n   "++
                                                 chain "\n   " (map show _rel))
            else head _rel
        (_rel) =
            irredS _lhs_gE [s| s <- _ss, _nm==name s, (a,b) <- _lhs_isign
                             , if _yin then source s `_lhs_gE` a && target s `_lhs_gE` b else target s `_lhs_gE` a && source s `_lhs_gE` b]
        (_ss) =
            let ss = [ s | s <- _lhs_sDef, name s == _nm] in
            if null _atts then rd ss else
            [ s | s <- ss, if _yin then source s == head _atts && target s == last _atts else source s == last _atts && target s == head _atts]
        (_ats) =
            rd ([C a _lhs_gE as|C a _ as<- _atts]++[S a _lhs_gE as|S a _ as<- _atts])
        ( _u_declaration,_u_nm,_u_rawDecl,_u_rnr,_u_rules,_u_sErr) =
            (_u (_lhs_gE) (-999999) (_lhs_sDef))
    in  (_ats
        ,False
        ,Mph _nm _pos _ats _s _yin
          (if null _rel then error("Fatal: null @rel in "++ _nm++" on "++show _pos++"\n@lhs.isign = "++ show _lhs_isign++"\n@ss       = "++ show _ss++"\n@s          = "++ show _s++"\n"++ gEtabG _lhs_gE (rd ([fst _s,snd _s]++concs _ss))) else
           head _rel)
        ,_nm
        ,_pos
        ,let err=error "illegal reference to 'raw' in semantics of Mph of Morphism" in
         if null _ats
         then (Mph _nm _pos _ats (Anything,Anything) _yin (Sgn _nm Anything Anything [] "" "" "" [] "" err 0 True), _ss)
         else (Mph _nm _pos _ats (if _yin then (head _ats,last _ats) else (last _ats,head _ats)) _yin (Sgn _nm (head _ats) (last _ats) [] "" "" "" [] "" err 0 True), _ss)
        ,[ "3 in "++show _pos++
           "\n   Relation " ++ show (Mph _nm _pos _atts (Anything, Anything) _yin (Isn Anything Anything)) ++
           (if null _atts then "" else show (rd _atts)) ++
           " is not declared.\n"
         | null _ss]
        ,_ss
        ,_yin
        )
sem_Morphism_V :: ([Concept]) ->
                  ((Concept,Concept)) ->
                  (T_Morphism)
sem_Morphism_V (_atts) (_sgn) (_lhs_gE) (_lhs_isign) (_lhs_sDef) =
    let (_rraw) =
            V _atts _sgn
        (_ats) =
            rd ([C a _lhs_gE as|C a _ as<- _atts]++[S a _lhs_gE as|S a _ as<- _atts])
    in  (_ats
        ,True
        ,let (s,t) = if null _lhs_isign then error ("Fatal: null @lhs.isign in V lhs.morphism! "++(show _atts)) else
                     head _lhs_isign
         in V _ats (s,t)
        ,"V"
        ,posNone
        ,( _rraw, [])
        ,[]
        ,declarations [ _rraw ]
        ,True
        )
-- Morphisms ---------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      isign                : [(Concept,Concept)]
      sDef                 : Declarations

   chained attributes:

   synthesised attributes:
      morphisms            : Morphisms
      raw                  : [(Morphism,Declarations)]
      usedDecls            : Declarations

-}
{-
   local variables for Morphisms.Cons:

-}
{-
   local variables for Morphisms.Nil:

-}
-- semantic domain
type T_Morphisms = (GenR) ->
                   ([(Concept,Concept)]) ->
                   (Declarations) ->
                   ((Morphisms),([(Morphism,Declarations)]),(Declarations))
-- cata
sem_Morphisms :: (Morphisms) ->
                 (T_Morphisms)
sem_Morphisms (list) =
    (foldr (sem_Morphisms_Cons) (sem_Morphisms_Nil) ((map sem_Morphism list)))
sem_Morphisms_Cons :: (T_Morphism) ->
                      (T_Morphisms) ->
                      (T_Morphisms)
sem_Morphisms_Cons (_hd) (_tl) (_lhs_gE) (_lhs_isign) (_lhs_sDef) =
    let ( _hd_atts,_hd_id,_hd_morphism,_hd_nm,_hd_pos,_hd_raw,_hd_sErr,_hd_usedDecls,_hd_yin) =
            (_hd (_lhs_gE)
                 (take 1 (
                   [ (src, if yin then target s else source s)
                   | (src,_)<- _lhs_isign, (Mph nm pos ats _ yin _,ss) <- [_hd_raw], s<-ss, (if yin then source s else target s) `_lhs_gE` src]++
                   _lhs_isign))
                 (_lhs_sDef))
        ( _tl_morphisms,_tl_raw,_tl_usedDecls) =
            (_tl (_lhs_gE) (_lhs_isign) (_lhs_sDef))
    in  (_hd_morphism : _tl_morphisms,_hd_raw : _tl_raw,_hd_usedDecls ++ _tl_usedDecls)
sem_Morphisms_Nil :: (T_Morphisms)
sem_Morphisms_Nil (_lhs_gE) (_lhs_isign) (_lhs_sDef) =
    let 
    in  ([],[],[])
-- ObjDefs -----------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      iConcs               : [Concept]
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      objDefs              : ObjDefs
      rules                : Rules
      sErr                 : [String]
      sources              : [Concept]

-}
{-
   local variables for ObjDefs.Cons:
      signs

-}
{-
   local variables for ObjDefs.Nil:

-}
-- semantic domain
type T_ObjDefs = (GenR) ->
                 ([Concept]) ->
                 (Int) ->
                 (Declarations) ->
                 ((ObjDefs),(Int),(Rules),([String]),([Concept]))
-- cata
sem_ObjDefs :: (ObjDefs) ->
               (T_ObjDefs)
sem_ObjDefs (list) =
    (foldr (sem_ObjDefs_Cons) (sem_ObjDefs_Nil) ((map sem_ObjectDef list)))
sem_ObjDefs_Cons :: (T_ObjectDef) ->
                    (T_ObjDefs) ->
                    (T_ObjDefs)
sem_ObjDefs_Cons (_hd) (_tl) (_lhs_gE) (_lhs_iConcs) (_lhs_rnr) (_lhs_sDef) =
    let (_signs) =
            rd [lubb _lhs_gE src' src''|src''<- _tl_sources, src'<- _hd_sConcs, src' `order` src'']
        ( _hd_ats,_hd_nm,_hd_odef,_hd_pos,_hd_rnr,_hd_rules,_hd_sConcs,_hd_sErr) =
            (_hd (_lhs_gE) (_lhs_iConcs) (_lhs_rnr) (_lhs_sDef))
        ( _tl_objDefs,_tl_rnr,_tl_rules,_tl_sErr,_tl_sources) =
            (_tl (_lhs_gE) (_lhs_iConcs) (_hd_rnr) (_lhs_sDef))
    in  (_hd_odef : _tl_objDefs,_tl_rnr,_hd_rules ++ _tl_rules,_hd_sErr ++ _tl_sErr,_signs)
sem_ObjDefs_Nil :: (T_ObjDefs)
sem_ObjDefs_Nil (_lhs_gE) (_lhs_iConcs) (_lhs_rnr) (_lhs_sDef) =
    let 
    in  ([],_lhs_rnr,[],[],[Anything])
-- ObjectDef ---------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      iConcs               : [Concept]
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      ats                  : ObjDefs
      nm                   : String
      odef                 : ObjectDef
      pos                  : FilePos
      rules                : Rules
      sConcs               : [Concept]
      sErr                 : [String]

-}
{-
   local variables for ObjectDef.Obj:
      signs

-}
-- semantic domain
type T_ObjectDef = (GenR) ->
                   ([Concept]) ->
                   (Int) ->
                   (Declarations) ->
                   ((ObjDefs),(String),(ObjectDef),(FilePos),(Int),(Rules),([Concept]),([String]))
-- cata
sem_ObjectDef :: (ObjectDef) ->
                 (T_ObjectDef)
sem_ObjectDef ((Obj (_nm) (_pos) (_ctx) (_ats))) =
    (sem_ObjectDef_Obj (_nm) (_pos) ((sem_Expression (_ctx))) ((sem_ObjDefs (_ats))))
sem_ObjectDef_Obj :: (String) ->
                     (FilePos) ->
                     (T_Expression) ->
                     (T_ObjDefs) ->
                     (T_ObjectDef)
sem_ObjectDef_Obj (_nm) (_pos) (_ctx) (_ats) (_lhs_gE) (_lhs_iConcs) (_lhs_rnr) (_lhs_sDef) =
    let (_signs) =
            rd [(lubb _lhs_gE s sa, lubb _lhs_gE t sb)| (s,t) <- _ctx_signs, sa <- _lhs_iConcs, sa `order` s, sb <- _ats_sources, sb `order` t]
        ( _ctx_expr,_ctx_morphisms,_ctx_raw,_ctx_rnr,_ctx_rules,_ctx_sErr,_ctx_signs) =
            (_ctx (_lhs_gE) (_signs) ("") (_pos) (_ats_rnr) (_lhs_sDef))
        ( _ats_objDefs,_ats_rnr,_ats_rules,_ats_sErr,_ats_sources) =
            (_ats (_lhs_gE) (_ats_sources) (_lhs_rnr) (_lhs_sDef))
    in  (_ats_objDefs
        ,_nm
        ,Obj _nm _pos _ctx_expr _ats_objDefs
        ,_pos
        ,_ctx_rnr
        ,_ats_rules ++ _ctx_rules
        ,rd (map fst _ctx_signs)
        ,_ctx_sErr++
         _ats_sErr++
         [ "9 on "++show _pos ++"\n   Cannot match "++
           chain "\n     or "
                 (map (\x-> "("++ _nm ++ ")["++show (fst x) ++ "*" ++ show (snd x) ++"]")
                 _ctx_signs)
           ++ "\n   to ["++
           chain "\n     or " (map show _lhs_iConcs)
           ++ "*"++
           chain "\n     or " (map show _ats_sources)
           ++ "]\n"
         | null _signs, not (null _ats_sources), not (null _lhs_iConcs)
         ]++
         [ "11 on "++show _pos ++"\n   Ambiguous types of "++ _nm
           ++ "\n       "++
           chain "\n     , "
                 (map (\x -> "["++show (fst x)++"*"++show (snd x)++"]")
                      _signs)
           ++ "\n"
         | length _signs > 1
         ]
        )
-- Pairs -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Pairs.Cons:

-}
{-
   local variables for Pairs.Nil:

-}
-- semantic domain
type T_Pairs = ()
-- cata
sem_Pairs :: (Pairs) ->
             (T_Pairs)
sem_Pairs (list) =
    (foldr (sem_Pairs_Cons) (sem_Pairs_Nil) (list))
sem_Pairs_Cons :: (Paire) ->
                  (T_Pairs) ->
                  (T_Pairs)
sem_Pairs_Cons (_hd) (_tl) =
    let 
    in  ()
sem_Pairs_Nil :: (T_Pairs)
sem_Pairs_Nil  =
    let 
    in  ()
-- Pattern -----------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      conDefs              : [ConceptDef]
      keyDefs              : KeyDefs
      mGen                 : Gens
      morphisms            : Morphisms
      patterns             : Patterns
      rawDecls             : Declarations
      rules                : Rules
      sErr                 : [String]
      usedDecls            : Declarations

-}
{-
   local variables for Pattern.Pat:

-}
-- semantic domain
type T_Pattern = (GenR) ->
                 (Int) ->
                 (Declarations) ->
                 (([ConceptDef]),(KeyDefs),(Gens),(Morphisms),(Patterns),(Declarations),(Int),(Rules),([String]),(Declarations))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Pat (_nm) (_rules) (_gen) (_pms) (_cs) (_ks))) =
    (sem_Pattern_Pat (_nm) ((sem_Rules (_rules))) ((sem_Gens (_gen))) ((sem_Declarations (_pms))) ((sem_ConceptDefs (_cs))) ((sem_KeyDefs (_ks))))
sem_Pattern_Pat :: (String) ->
                   (T_Rules) ->
                   (T_Gens) ->
                   (T_Declarations) ->
                   (T_ConceptDefs) ->
                   (T_KeyDefs) ->
                   (T_Pattern)
sem_Pattern_Pat (_nm) (_rules) (_gen) (_pms) (_cs) (_ks) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let ( _rules_declarations,_rules_mGen,_rules_morphisms,_rules_rnr,_rules_rules,_rules_sErr,_rules_usedDecls) =
            (_rules (_lhs_gE) (_nm) (_gen_rnr) (_lhs_sDef))
        ( _gen_list,_gen_rnr,_gen_rules) =
            (_gen (_lhs_gE) (_nm) (_lhs_rnr))
        ( _pms_declarations,_pms_rawDecls,_pms_rnr,_pms_rules,_pms_sErr) =
            (_pms (_lhs_gE) (_rules_rnr) (_lhs_sDef))
        ( _cs_conDefs) =
            (_cs )
        ( _ks_exprs,_ks_keyDefs,_ks_rnr,_ks_rules,_ks_sErr) =
            (_ks (_lhs_gE) (_pms_rnr) (_lhs_sDef))
    in  (_cs_conDefs
        ,_ks_keyDefs
        ,rd [G pos g s| G pos g s <- _rules_mGen ++ _gen_list, g/=s]
        ,_rules_morphisms
        ,[Pat _nm _rules_rules ( _rules_mGen ++ _gen_list)
              ( _pms_declarations ++ _rules_declarations )
              _cs_conDefs _ks_keyDefs]
        ,_pms_rawDecls
        ,_ks_rnr
        ,_gen_rules ++ _rules_rules ++ _pms_rules ++ _ks_rules
        ,_rules_sErr ++ _pms_sErr ++ _ks_sErr
        ,_rules_usedDecls ++declarations _ks_exprs
        )
-- Patterns ----------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      conDefs              : [ConceptDef]
      keyDefs              : KeyDefs
      mGen                 : Gens
      morphisms            : Morphisms
      patterns             : Patterns
      rawDecls             : Declarations
      rules                : Rules
      sErr                 : [String]
      usedDecls            : Declarations

-}
{-
   local variables for Patterns.Cons:

-}
{-
   local variables for Patterns.Nil:

-}
-- semantic domain
type T_Patterns = (GenR) ->
                  (Int) ->
                  (Declarations) ->
                  (([ConceptDef]),(KeyDefs),(Gens),(Morphisms),(Patterns),(Declarations),(Int),(Rules),([String]),(Declarations))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (_hd) (_tl) (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let ( _hd_conDefs,_hd_keyDefs,_hd_mGen,_hd_morphisms,_hd_patterns,_hd_rawDecls,_hd_rnr,_hd_rules,_hd_sErr,_hd_usedDecls) =
            (_hd (_lhs_gE) (_lhs_rnr) (_lhs_sDef))
        ( _tl_conDefs,_tl_keyDefs,_tl_mGen,_tl_morphisms,_tl_patterns,_tl_rawDecls,_tl_rnr,_tl_rules,_tl_sErr,_tl_usedDecls) =
            (_tl (_lhs_gE) (_hd_rnr) (_lhs_sDef))
    in  (_hd_conDefs ++ _tl_conDefs,_hd_keyDefs ++ _tl_keyDefs,_hd_mGen ++ _tl_mGen,_hd_morphisms ++ _tl_morphisms,_hd_patterns ++ _tl_patterns,_hd_rawDecls ++ _tl_rawDecls,_tl_rnr,_hd_rules ++ _tl_rules,_hd_sErr ++ _tl_sErr,rd(_hd_usedDecls ++ _tl_usedDecls))
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil (_lhs_gE) (_lhs_rnr) (_lhs_sDef) =
    let 
    in  ([],[],[],[],[],[],_lhs_rnr,[],[],[])
-- Population --------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      sDef                 : Declarations

   chained attributes:

   synthesised attributes:
      pop                  : Population
      sErr                 : [String]

-}
{-
   local variables for Population.Popu:

-}
-- semantic domain
type T_Population = (GenR) ->
                    (Declarations) ->
                    ((Population),([String]))
-- cata
sem_Population :: (Population) ->
                  (T_Population)
sem_Population ((Popu (_m) (_ps))) =
    (sem_Population_Popu ((sem_Morphism (_m))) (_ps))
sem_Population_Popu :: (T_Morphism) ->
                       ([Paire]) ->
                       (T_Population)
sem_Population_Popu (_m) (_ps) (_lhs_gE) (_lhs_sDef) =
    let ( _m_atts,_m_id,_m_morphism,_m_nm,_m_pos,_m_raw,_m_sErr,_m_usedDecls,_m_yin) =
            (_m (_lhs_gE) (let (m,ss) = _m_raw in if isMph m then (if inline m then map sign ss else map (sign.flp) ss) else [sign m]) (_lhs_sDef))
    in  (Popu _m_morphism _ps,_m_sErr)
-- Populations -------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      sDef                 : Declarations

   chained attributes:

   synthesised attributes:
      popus                : Populations
      sErr                 : [String]

-}
{-
   local variables for Populations.Cons:

-}
{-
   local variables for Populations.Nil:

-}
-- semantic domain
type T_Populations = (GenR) ->
                     (Declarations) ->
                     ((Populations),([String]))
-- cata
sem_Populations :: (Populations) ->
                   (T_Populations)
sem_Populations (list) =
    (foldr (sem_Populations_Cons) (sem_Populations_Nil) ((map sem_Population list)))
sem_Populations_Cons :: (T_Population) ->
                        (T_Populations) ->
                        (T_Populations)
sem_Populations_Cons (_hd) (_tl) (_lhs_gE) (_lhs_sDef) =
    let ( _hd_pop,_hd_sErr) =
            (_hd (_lhs_gE) (_lhs_sDef))
        ( _tl_popus,_tl_sErr) =
            (_tl (_lhs_gE) (_lhs_sDef))
    in  (_hd_pop : _tl_popus,_hd_sErr ++ _tl_sErr)
sem_Populations_Nil :: (T_Populations)
sem_Populations_Nil (_lhs_gE) (_lhs_sDef) =
    let 
    in  ([],[])
-- Prop --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Prop.Asy:

-}
{-
   local variables for Prop.Inj:

-}
{-
   local variables for Prop.Sur:

-}
{-
   local variables for Prop.Sym:

-}
{-
   local variables for Prop.Tot:

-}
{-
   local variables for Prop.Trn:

-}
{-
   local variables for Prop.Uni:

-}
-- semantic domain
type T_Prop = ()
-- cata
sem_Prop :: (Prop) ->
            (T_Prop)
sem_Prop ((Asy )) =
    (sem_Prop_Asy )
sem_Prop ((Inj )) =
    (sem_Prop_Inj )
sem_Prop ((Sur )) =
    (sem_Prop_Sur )
sem_Prop ((Sym )) =
    (sem_Prop_Sym )
sem_Prop ((Tot )) =
    (sem_Prop_Tot )
sem_Prop ((Trn )) =
    (sem_Prop_Trn )
sem_Prop ((Uni )) =
    (sem_Prop_Uni )
sem_Prop_Asy :: (T_Prop)
sem_Prop_Asy  =
    let 
    in  ()
sem_Prop_Inj :: (T_Prop)
sem_Prop_Inj  =
    let 
    in  ()
sem_Prop_Sur :: (T_Prop)
sem_Prop_Sur  =
    let 
    in  ()
sem_Prop_Sym :: (T_Prop)
sem_Prop_Sym  =
    let 
    in  ()
sem_Prop_Tot :: (T_Prop)
sem_Prop_Tot  =
    let 
    in  ()
sem_Prop_Trn :: (T_Prop)
sem_Prop_Trn  =
    let 
    in  ()
sem_Prop_Uni :: (T_Prop)
sem_Prop_Uni  =
    let 
    in  ()
-- Rule --------------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      pn                   : String
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      declarations         : Declarations
      mGen                 : Gens
      morphisms            : Morphisms
      rules                : Rules
      sErr                 : [String]
      usedDecls            : Declarations

-}
{-
   local variables for Rule.Gc:
      esign
      ms
      closdecls
      ruls
      mors
      rs

-}
{-
   local variables for Rule.Ru:
      s
      is
      clrs
      closdecls
      rcpu
      errcpu
      rs
      r

-}
{-
   local variables for Rule.Sg:
      rs
      signalname

-}
-- semantic domain
type T_Rule = (GenR) ->
              (String) ->
              (Int) ->
              (Declarations) ->
              ((Declarations),(Gens),(Morphisms),(Int),(Rules),([String]),(Declarations))
-- cata
sem_Rule :: (Rule) ->
            (T_Rule)
sem_Rule ((Gc (_gluePos) (_m) (_expr) (_cpu) (_sgn) (_nr) (_pn))) =
    (sem_Rule_Gc (_gluePos) ((sem_Morphism (_m))) ((sem_Expression (_expr))) ((sem_Expressions (_cpu))) (_sgn) (_nr) (_pn))
sem_Rule ((Ru (_c) (_antc) (_rulePos) (_cons) (_cpu) (_expl) (_sgn) (_nr) (_pn))) =
    (sem_Rule_Ru (_c) ((sem_Expression (_antc))) (_rulePos) ((sem_Expression (_cons))) ((sem_Expressions (_cpu))) (_expl) (_sgn) (_nr) (_pn))
sem_Rule ((Sg (_pos) (_rule) (_expl) (_sgn) (_nr) (_pn) (_signal))) =
    (sem_Rule_Sg (_pos) ((sem_Rule (_rule))) (_expl) (_sgn) (_nr) (_pn) ((sem_Declaration (_signal))))
sem_Rule_Gc :: (FilePos) ->
               (T_Morphism) ->
               (T_Expression) ->
               (T_Expressions) ->
               ((Concept,Concept)) ->
               (Int) ->
               (String) ->
               (T_Rule)
sem_Rule_Gc (_gluePos) (_m) (_expr) (_cpu) (_sgn) (_nr) (_pn) (_lhs_gE) (_lhs_pn) (_lhs_rnr) (_lhs_sDef) =
    let (_rs) =
            [ Ru c antc pos expr cpu expla (a,b) (i + _lhs_rnr) _lhs_pn
            | ((Ru c antc pos expr cpu expla (a,b) _ _,cpuErrs), i)<-zip _ruls [0..]] ++ _expr_rules
        (_mors) =
            _m_morphism : _expr_morphisms
        (_ruls) =
            [ subExprCheck (Ru 'I' (Tm _m_morphism) _gluePos _expr_expr _cpu_raw "" (a,b) _nr _lhs_pn)
            | (d,c) <- _expr_signs, s <- _m_usedDecls
            , if d `_lhs_gE` source _m_morphism && c `_lhs_gE` target _m_morphism then True else
              error ("Fatal: (please report this as an error in ADL)\nFalse assumption in alternative Gc of SEM Rule, that "++show (d,c)++" in @expr.signs be more general than "++ show (source _m_morphism,target _m_morphism)++".")
            , (a,b)<-[if null _m_atts then (source _m_morphism,target _m_morphism) else (head _m_atts,last _m_atts)]]
        (_closdecls) =
            rd [s| Ru c antc p cons cpu expla (a,b) n pn <- _expr_rules, s<-declarations antc]
        (_ms) =
            irredT _lhs_gE
             (if null _expr_signs
              then [(source m,target m)| m <- _m_usedDecls]
              else [(source m,target m)| m <- _m_usedDecls
                                       , or[s `_lhs_gE` source m && t `_lhs_gE` target m
                                           | (s,t) <- _expr_signs ]
                   ])
        (_esign) =
            irredT _lhs_gE _expr_signs
        ( _m_atts,_m_id,_m_morphism,_m_nm,_m_pos,_m_raw,_m_sErr,_m_usedDecls,_m_yin) =
            (_m (_lhs_gE) (_ms) (_lhs_sDef))
        ( _expr_expr,_expr_morphisms,_expr_raw,_expr_rnr,_expr_rules,_expr_sErr,_expr_signs) =
            (_expr (_lhs_gE) (_esign) (_lhs_pn) (_gluePos) (_lhs_rnr+length _rs) (_lhs_sDef))
        ( _cpu_exprs,_cpu_morphisms,_cpu_raw,_cpu_rnr,_cpu_rules,_cpu_sErr,_cpu_signss) =
            (_cpu (_lhs_gE) ([]) (_lhs_pn) (_gluePos) (_expr_rnr) (_lhs_sDef) ([]))
    in  ([]
        ,rd [G pos g s| (d,c) <- _expr_signs, m <- _m_usedDecls, G pos g s<-[G _gluePos d (source m), G _gluePos c (target m)], g/=s]
        ,_mors
        ,_expr_rnr
        ,_rs
        ,take 1
          (  [ "12 in "++show _gluePos++
               "\n   I not allowed as left hand side of GLUE\n"
             | null _ms && _m_id]
          ++ ["13 in "++show _gluePos++
               "\n   I not allowed as right hand side of GLUE\n"
             | anything _expr_signs]
          ++ _m_sErr ++ _expr_sErr
          )
        ,rd (declarations _mors ++ _closdecls)
        )
sem_Rule_Ru :: (Char) ->
               (T_Expression) ->
               (FilePos) ->
               (T_Expression) ->
               (T_Expressions) ->
               (String) ->
               ((Concept,Concept)) ->
               (Int) ->
               (String) ->
               (T_Rule)
sem_Rule_Ru (_c) (_antc) (_rulePos) (_cons) (_cpu) (_expl) (_sgn) (_nr) (_pn) (_lhs_gE) (_lhs_pn) (_lhs_rnr) (_lhs_sDef) =
    let (_r) =
            fst _rcpu
        (_rs) =
            [ _r ] ++ _clrs
        (_errcpu) =
            snd _rcpu
        (_rcpu) =
            subExprCheck
            (if _c=='A'
            then Ru _c (error ("Reference to antecedent of 'A' Rule "++showHS "" _r)) _rulePos _cons_expr _cpu_raw _expl
                    (if null _is
                     then error("Fatal: null @is on "++show _rulePos++"\n@cons.expr = "++show _cons_expr++"\n@cons.signs = "++shSigns _cons_signs)
                     else head _is)
                     _lhs_rnr _lhs_pn
            else Ru _c _antc_expr _rulePos _cons_expr _cpu_raw _expl
                    (if null _is
                     then error("Fatal: null @is on "++show _rulePos++"\n@antc.expr = "++show _antc_expr++"\n@antc.signs = "++shSigns _antc_signs++"\n@cons.expr = "++show _cons_expr++"\n@cons.signs = "++shSigns _cons_signs)
                     else head _is)
                    _lhs_rnr _lhs_pn)
        (_closdecls) =
            rd [s| Ru c antc p cons cpu expla (a,b) n pn <- _clrs, s<-declarations antc]
        (_clrs) =
            if _c=='A'
            then _cons_rules
            else _antc_rules ++ _cons_rules
        (_is) =
            if _c=='A' then _cons_signs else
            if null _antc_signs
            then (if null _cons_signs
                  then []
                  else _cons_signs)
            else (if null _cons_signs
                  then _antc_signs
                  else _s)
        (_s) =
            if _c=='A' then _cons_signs else
            irredT _lhs_gE [ (if a `_lhs_gE` a' then a' else a, if b `_lhs_gE` b' then b' else b)
                           | (a,b)<- _cons_signs, (a',b')<- _antc_signs
                           , (a `_lhs_gE` a' || a' `_lhs_gE` a) && (b `_lhs_gE` b' || b' `_lhs_gE` b)
                           ]
        ( _antc_expr,_antc_morphisms,_antc_raw,_antc_rnr,_antc_rules,_antc_sErr,_antc_signs) =
            (_antc (_lhs_gE) (if null _is then _antc_signs else _is) (_lhs_pn) (_rulePos) (_lhs_rnr + 1) (_lhs_sDef))
        ( _cons_expr,_cons_morphisms,_cons_raw,_cons_rnr,_cons_rules,_cons_sErr,_cons_signs) =
            (_cons (_lhs_gE) (if null _is then _cons_signs else _is) (_lhs_pn) (_rulePos) (if _c=='A' then _lhs_rnr + 1 else _antc_rnr) (_lhs_sDef))
        ( _cpu_exprs,_cpu_morphisms,_cpu_raw,_cpu_rnr,_cpu_rules,_cpu_sErr,_cpu_signss) =
            (_cpu (_lhs_gE) (_is) (_lhs_pn) (_rulePos) (_cons_rnr) (_lhs_sDef) ([]))
    in  ([]
        ,[]
        ,(if _c=='A' then [] else _antc_morphisms)++ _cons_morphisms
        ,_cons_rnr
        ,_rs
        ,take 1
         (_cons_sErr ++
           (if _c=='A' then [] else _antc_sErr ++
            [ "8 in "++show _rulePos++"\n   Meaningless rule.\n"
            | null _cons_signs&&null _antc_signs]++
            [ "1 in "++show _rulePos++"\n   Mismatch in rule:\n   "++
              show _antc_expr++ " :: "++shSigns _antc_signs ++ "\n   does not match\n   "++
              show _cons_expr++ " :: "++shSigns _cons_signs++"\n"
            | null _is && not (null _antc_signs) && not (null _cons_signs)]++
            [ "2 in "++show _rulePos++"\n   Ambiguous types: "++shSigns _is++
              "\n   in right hand side:  "++ show _cons_expr++
              "\n   and left hand side:  "++ show _antc_expr++"\n"
            | length _is>1]++
            [ "15 in "++show _rulePos++
              "\n   the right hand side: "++ show _cons_expr++" has type "++shSigns [(s,t)| (s,t) <- _is, not(s `order` t)]++
              "\n   and left hand side:  "++ show _antc_expr++" requires that source and target are the same.\n"
            | isIdent _antc_expr && or [not(s `order` t)| (s,t) <- _is] ]++
            [ "16 in "++show _rulePos++
              "\n   the left hand side:  "++ show _cons_expr++" has type "++shSigns [(s,t)| (s,t) <- _is, not(s `order` t)]++
              "\n   and right hand side: "++ show _antc_expr++" requires that source and target are the same.\n"
            | isIdent _cons_expr && or [not(s `order` t)| (s,t) <- _is] ]++
            [ "14 in "++show _rulePos++" rule "++show (nr _r)++":\n   "++showADL _r++"\n   "++chain "\n   " _errcpu++"\n"
            | not (null _errcpu)]))
        ,rd (declarations (_antc_morphisms ++ _cons_morphisms) ++ _closdecls)
        )
sem_Rule_Sg :: (FilePos) ->
               (T_Rule) ->
               (String) ->
               ((Concept,Concept)) ->
               (Int) ->
               (String) ->
               (T_Declaration) ->
               (T_Rule)
sem_Rule_Sg (_pos) (_rule) (_expl) (_sgn) (_nr) (_pn) (_signal) (_lhs_gE) (_lhs_pn) (_lhs_rnr) (_lhs_sDef) =
    let (_signalname) =
            if null _signal_nm || take 6 _signal_nm == "Signal" && and [isDigit c| c<-drop 6 _signal_nm ]
            then "Signal"++show _lhs_rnr else _signal_nm
        (_rs) =
            [ Sg p r expla sgn n _lhs_pn (Sgn _signalname a b [] "" "" "" [] "" _pos _lhs_rnr True)
            | r@(Ru c antc p cons cpu expla sgn n _lhs_pn)<-take 1 _rule_rules
            , (a,b)<-[sign r] ] ++ drop 1 _rule_rules
        ( _rule_declarations,_rule_mGen,_rule_morphisms,_rule_rnr,_rule_rules,_rule_sErr,_rule_usedDecls) =
            (_rule (_lhs_gE) (_lhs_pn) (_lhs_rnr) (_lhs_sDef))
        ( _signal_declaration,_signal_nm,_signal_rawDecl,_signal_rnr,_signal_rules,_signal_sErr) =
            (_signal (_lhs_gE) (_rule_rnr) (_lhs_sDef))
    in  (declarations _rs
        ,[]
        ,_rule_morphisms
        ,if null _signal_nm || take 6 _signal_nm == "Signal" && and [isDigit c| c<-drop 6 _signal_nm ]
         then _lhs_rnr + 1 else _lhs_rnr
        ,_rs
        ,_rule_sErr
        ,rd (declarations _rule_morphisms)
        )
-- Rules -------------------------------------------------------
{-
   inherited attributes:
      gE                   : GenR
      pn                   : String
      sDef                 : Declarations

   chained attributes:
      rnr                  : Int

   synthesised attributes:
      declarations         : Declarations
      mGen                 : Gens
      morphisms            : Morphisms
      rules                : Rules
      sErr                 : [String]
      usedDecls            : Declarations

-}
{-
   local variables for Rules.Cons:

-}
{-
   local variables for Rules.Nil:

-}
-- semantic domain
type T_Rules = (GenR) ->
               (String) ->
               (Int) ->
               (Declarations) ->
               ((Declarations),(Gens),(Morphisms),(Int),(Rules),([String]),(Declarations))
-- cata
sem_Rules :: (Rules) ->
             (T_Rules)
sem_Rules (list) =
    (foldr (sem_Rules_Cons) (sem_Rules_Nil) ((map sem_Rule list)))
sem_Rules_Cons :: (T_Rule) ->
                  (T_Rules) ->
                  (T_Rules)
sem_Rules_Cons (_hd) (_tl) (_lhs_gE) (_lhs_pn) (_lhs_rnr) (_lhs_sDef) =
    let ( _hd_declarations,_hd_mGen,_hd_morphisms,_hd_rnr,_hd_rules,_hd_sErr,_hd_usedDecls) =
            (_hd (_lhs_gE) (_lhs_pn) (_lhs_rnr) (_lhs_sDef))
        ( _tl_declarations,_tl_mGen,_tl_morphisms,_tl_rnr,_tl_rules,_tl_sErr,_tl_usedDecls) =
            (_tl (_lhs_gE) (_lhs_pn) (_hd_rnr) (_lhs_sDef))
    in  (_hd_declarations ++ _tl_declarations,_hd_mGen ++ _tl_mGen,_hd_morphisms ++ _tl_morphisms,_tl_rnr,_hd_rules ++ _tl_rules,_hd_sErr ++ _tl_sErr,_hd_usedDecls ++ _tl_usedDecls)
sem_Rules_Nil :: (T_Rules)
sem_Rules_Nil (_lhs_gE) (_lhs_pn) (_lhs_rnr) (_lhs_sDef) =
    let 
    in  ([],[],[],_lhs_rnr,[],[],[])

