CONTEXT Atlas: user;s[User*User];user~ /\ script;s[Script*Script];script~ 
BINDING 
BIND s::User*User. TOPHP "User", 
BIND s::Script*Script. TOPHP "Script"

--QUICK IMPLEMENTATION FOR ATLAS:
--ONLY PHP/SQL select queries are implemented and tested for context expressions
--The context expression MUST be an intersection with all conjuncts of the format (r;s[R*R];r~) where r::Aything->R and s a singleton relation of type R
--r must be explicitly declared for all Concepts in this Context. s must be explicitly declared. 
-- (a DB table will be created for s, but it does not need to be populated while it is not used in any SELECT query)
--PHP binds the concept name of the singleton in the global variable ctxenv
-- ($GLOBALS['ctxenv']=array('User'=>$_REQUEST['User'],'Script'=>$_REQUEST['Script'])) 
{- The generated SELECT query for Atlas
SELECT DISTINCT TODO.`i`, TODO.`i` AS i1
FROM `#TABLE#` AS TODO
WHERE TODO.`script`='".$GLOBALS['ctxenv']['Script']."'
  AND TODO.`user`='".$GLOBALS['ctxenv']['User']."'
-}
--USAGE -> The context expression can be used in composition on all V[Anything*Anything] and I[Anything], like expr;V;expr. When the source or target is ONE, this is not needed, which saves a declaration r::ONE->R.
--Compiletime checks are on context expressions minimal while still only used for Atlas.
--GEN/SPEC is not considered yet, while it does not work properly in PHP at this moment.

--TODO -> WHILE GEN does not work well in prototype it is best to first define relations on 
--specific concept -> general properties are translated into columns at the end, so they can be removed more easily

PATTERN Atlas
thepicture::Picture->Picture.

-- a relation variable can be overloaded -> no function
-- TODO -> namespaces?
relvar::Relation*Type.
contains::Relation*Pair.
contains::Concept*Atom.

source::Type->Concept.
target::Type->Concept.

--IsaRelation contains only user-defined isa relations, not derived ones
specific::IsaRelation->Concept. 
general::IsaRelation->Concept.
ENDPATTERN
PATTERN Rules

{--SPECIFIC RULE DECLARATIONS--}
--GEN UserRule ISA Rule
--GEN MultiplicityRule ISA Rule
--GEN HomogeneousRule ISA Rule
morphisms::UserRule*Relation.
property::MultiplicityRule->Prop.
on::MultiplicityRule->Relation.
property::HomogeneousRule->Prop.
on::HomogeneousRule->Relation.

{--GENERAL RULE DECLARATIONS--}
--GEN Rule ISA Expression
--GEN Morphism ISA Expression
--type::Expression->Type.
type::Rule->Type.
type::UserRule->Type.
type::MultiplicityRule->Type.
type::HomogeneousRule->Type.
--type::Morphism->Type.
violates::Violation*Rule.
violates::Violation*UserRule.
violates::Violation*MultiplicityRule.
violates::Violation*HomogeneousRule.
explanation::Rule->Explanation.
explanation::UserRule->Explanation.
explanation::MultiplicityRule->Explanation.
explanation::HomogeneousRule->Explanation.
ENDPATTERN

PATTERN ExplicitUserContext
s::User*User. 
s::Script*Script. 

user::Picture->User.
user::Relation->User.
user::Type->User.
user::Pair->User.
user::Concept->User.
user::Atom->User.
user::IsaRelation->User.
user::MultiplicityRule->User.
user::HomogeneousRule->User.
user::Prop->User.
user::UserRule->User.
user::Rule->User.
user::Violation->User.
user::Explanation->User.
--ctxenv::Picture*Picture.
--ctxenv::Relation*Relation.
--ctxenv::Concept*Concept.
--ctxenv::IsaRelation*IsaRelation.
--ctxenv::MultiplicityRule*MultiplicityRule.
--ctxenv::HomogeneousRule*HomogeneousRule.
--ctxenv::UserRule*UserRule.
--ctxenv::Rule*Rule.
script::Picture->Script.
script::Relation->Script.
script::Type->Script.
script::Pair->Script.
script::Concept->Script.
script::Atom->Script.
script::IsaRelation->Script.
script::MultiplicityRule->Script.
script::HomogeneousRule->Script.
script::Prop->Script.
script::UserRule->Script.
script::Rule->Script.
script::Violation->Script.
script::Explanation->Script.
ENDPATTERN

PATTERN ExplicitDisplay
--All Atlas concepts need to be qualified identity strings to prevent mixture of adl scripts
display::Picture->String.
display::Relation->String.
display::Type->String.
display::Pair->String.
display::Concept->String.
display::Atom->String.
display::IsaRelation->String.
display::MultiplicityRule->String.
display::HomogeneousRule->String.
display::Prop->String.
display::UserRule->String.
display::Rule->String.
display::Violation->String.
display::Explanation->String.
ENDPATTERN

-- {"DISPLAY=<Concept>.<(function)Relation>"} if you need the link by id and a user-friendly representation.
--example DISPLAY=Relation.display to print the user-friendly string of a Relation
--TODO -> There are no compile checks to check on the correct type or to check that the relation is represented as a DB column of the table of that type. In case of mistakes the PHP will return a missing offset 0, because it will try to get $rows[0].
--TODO -> DISPLAY has not been tested on all types of ObjectDefs (see Wrapper.hs -> attContent for different patterns)
SERVICE Rules : I[ONE]
   = [ "Conceptual diagram"{"PICTURE"}: V[ONE*Picture];(user;s;user[Picture*User]~ /\ script;s;script~);display
     , "User-defined rules" : V[ONE*UserRule];(user;s;user[UserRule*User]~ /\ script;s;script~)
         = [ rule : I[UserRule];display
           , source{"DISPLAY=Concept.display"} : type;source
           , target{"DISPLAY=Concept.display"} : type;target
           , violations : violates~;display
           ]
     , Multiplicities : V[ONE*MultiplicityRule];(user;s;user[MultiplicityRule*User]~ /\ script;s;script~)
         = [ property : property;display
           , source{"DISPLAY=Concept.display"} : type;source
           , on{"DISPLAY=Relation.display"} : on
           , rule : I[MultiplicityRule];display
           , violations : violates~;display
           ]
     , "Homogeneous properties" : V[ONE*HomogeneousRule];(user;s;user[HomogeneousRule*User]~ /\ script;s;script~)
         = [ property : property;display
           , on{"DISPLAY=Relation.display"} : on
           , rule : I[HomogeneousRule];display
           , violations : violates~;display
           ]
      ] 

--TODO -> specific types moeten doorlinken naar generiekere service, als geen specifieke service bestaat
--TODO -> relations op generieke types moeten herkend worden, zodat juiste SQL gemaakt kan worden
--        nu wordt default de specieke tabel gebruikt voor alle relaties!
SERVICE Rule{"DISPLAY=Rule.display"} : I[Rule]
   = [ source{"DISPLAY=Concept.display"} : type;source
     , target{"DISPLAY=Concept.display"} : type;target
     , violations : violates~;display
     , explanation : explanation;display]
SERVICE Rule1{"DISPLAY=UserRule.display"} : I[UserRule]
   = [ source{"DISPLAY=Concept.display"} : type;source
     , target{"DISPLAY=Concept.display"} : type;target
     , relations{"DISPLAY=Relation.display"} : morphisms
     , violations : violates~;display
     , explanation : explanation;display]
SERVICE Rule2{"DISPLAY=MultiplicityRule.display"} : I[MultiplicityRule]
   = [ "property of relation"{"DISPLAY=Relation.display"} : on
     , violations : violates~;display
     , explanation : explanation;display]
SERVICE Rule3{"DISPLAY=HomogeneousRule.display"} : I[HomogeneousRule]
   = [ "property of relation"{"DISPLAY=Relation.display"} : on
     , violations : violates~;display
     , explanation : explanation;display]

SERVICE "ISArelations" : I[ONE]
   = [ "IS-a relations" :  V[ONE*IsaRelation];(user;s;user[IsaRelation*User]~ /\ script;s;script~)
      = [ "IS-a relation" : display
        , specific {"DISPLAY=Concept.display"}: specific
        , isa {"DISPLAY=Concept.display"}: general
        ]
     ]

--I must use a nested name to display, because there is no SERVICE on String only on Relation
SERVICE Relations : I[ONE]
   = [ Relation_s{"DISPLAY=Relation.display"} : V[ONE*Relation];(user;s;user[Relation*User]~ /\ script;s;script~)]

--I do not want to display the qualified name, but the unqualified one
--TODO -> in case of overloaded relation variables, the populations are merged 
SERVICE "RelationDetails"{"DISPLAY=Relation.display"}   : I[Relation]
   = [ type        : relvar;display
     , "source(s)"{"DISPLAY=Concept.display"} : relvar;source
     , "target(s)"{"DISPLAY=Concept.display"} : relvar;target
     , "multiplicity properties" : (on[MultiplicityRule*Relation])~
       = [property : property;display, "derived rule" : display, violations : violates~;display]
     , "homogeneous properties"  : (on[HomogeneousRule*Relation])~
       = [property : property;display, "derived rule" : display, violations : violates~;display]
     , population  : contains;display
     , "used in rules"{"DISPLAY=UserRule.display"} : morphisms~]

SERVICE Population{"DISPLAY=Relation.display"}   : I[Relation]
   = [ population  : contains;display]

SERVICE Concepts : I[ONE]
   = [ Concept_s{"DISPLAY=Concept.display"} : V[ONE*Concept];(user;s;user[Concept*User]~ /\ script;s;script~)]

SERVICE Concept{"DISPLAY=Concept.display"} : I[Concept]
   = [ population : contains;display]

ENDCONTEXT

{-

  function display($tbl,$col,$id){
     return firstRow(firstCol(DB_doquer("SELECT DISTINCT `".$col."` FROM `".$tbl."` WHERE `i`='".addslashes($id)."'")));
  }

      <DIV class="FloaterContent"><?php
          $type = $Relation->get_type();
          echo '
          <UL>';
	  foreach($type as $i0=>$idv0){
	    $v0 = display('type','display',$idv0);
            echo '
            <LI CLASS="item UI_type" ID="1.'.$i0.'">';
              if(!$edit) echo '
              <A HREF="'.serviceref('Type', array('Type'=>urlencode($idv0))).'">'.htmlspecialchars($v0).'</A>';
              else echo htmlspecialchars($v0);
            echo '</LI>';
          }


else echo '<H1>'.display('relation','display',$Relation->getId()).'</H1>';
-}

{- Gezocht wordt naar de kolom UserRule, omdat dit zo bepaald is door het
type in de expressie. Maar deze kolom heeft de naam van het generale type Rule, omdat dit zo gedeclareerd is.
Eén of andere join nodig?

SELECT DISTINCT `f1`.`UserRule` AS `id`
FROM  ( SELECT DISTINCT csnd.i AS `UserRule`
FROM `userrule` AS csnd
) AS f1



SELECT DISTINCT 
  `f3`.`UserRule` AS `id`
  ,`f3`.`UserRule` AS `rule`
  , `f3`.`source`
FROM `userrule`
LEFT JOIN  
  ( SELECT DISTINCT F0.`UserRule`, F1.`source`
    FROM `rule` AS F0, `type` AS F1
    WHERE F0.`Type`=F1.`i`
   ) AS f3
ON `f3`.`UserRule`='accepted |- addressedTo~'
WHERE `userrule`.`i`='accepted |- addressedTo~'


SELECT DISTINCT 
     'paid |- sentTo~' AS `id` 
   , 'paid |- sentTo~' AS `rule`
   , `f3`.`source` 
FROM `userrule` 
LEFT JOIN 
     ( SELECT DISTINCT 
            F0.`UserRule`
          , F1.`source` 
       FROM `rule` AS F0, `type` AS F1 
       WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`UserRule`='paid |- sentTo~' 
WHERE `userrule`.`i`='paid |- sentTo~'

SELECT DISTINCT 
     'paid |- sentTo~' AS `id` 
   , 'paid |- sentTo~' AS `rule`
   , `f3`.`source` 
FROM `userrule` 
LEFT JOIN 
     ( SELECT DISTINCT 
            F0.`i`
          , F1.`source` 
       FROM `rule` AS F0, `type` AS F1 
       WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='paid |- sentTo~' 
WHERE `userrule`.`i`='paid |- sentTo~'

-------------------------------------
SELECT DISTINCT `f1`.`Violation` AS `violations` FROM `userrule` JOIN `violates` AS f1 ON `f1`.`UserRule`='accepted;of~ |- provided' WHERE `userrule`.`i`='accepted;of~ |- provided'
----------------------------------------------------
SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `f2`.`property` 
  , `f3`.`source` 
  , `f4`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN `multiplicityrule` AS f2 
ON `f2`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`MultiplicityRule`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`MultiplicityRule`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN `multiplicityrule` AS f4 
ON `f4`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'

SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `f2`.`property` 
  , `f3`.`source` 
  , `f4`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN `multiplicityrule` AS f2 
ON `f2`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`i`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN `multiplicityrule` AS f4 
ON `f4`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'


SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `multiplicityrule`.`property` 
  , `f3`.`source` 
  , `multiplicityrule`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`i`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'
-}
