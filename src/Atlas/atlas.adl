CONTEXT Atlas: user;s[User*User];user~ /\ script;s[Script*Script];script~ 
BINDING 
BIND s::User*User. TOPHP "User", 
BIND s::Script*Script. TOPHP "Script"

--QUICK IMPLEMENTATION FOR ATLAS:
--ONLY PHP/SQL select queries are implemented and tested for context expressions
--The context expression MUST be an intersection with all conjuncts of the format (r;s[R*R];r~) where r::Aything->R and s a singleton relation of type R
--r must be explicitly declared for all Concepts in this Context. s must be explicitly declared. 
-- (a DB table will be created for s, but it does not need to be populated while it is not used in any SELECT query)
--PHP binds the concept name of the singleton in the global variable ctxenv
-- ($GLOBALS['ctxenv']=array('User'=>$_REQUEST['User'],'Script'=>$_REQUEST['Script'])) 
{- The generated SELECT query for Atlas
SELECT DISTINCT TODO.`i`, TODO.`i` AS i1
FROM `#TABLE#` AS TODO
WHERE TODO.`script`='".$GLOBALS['ctxenv']['Script']."'
  AND TODO.`user`='".$GLOBALS['ctxenv']['User']."'
-}
--USAGE -> The context expression should be used in composition on all V[Anything*Anything], like expr;V;expr. When the source or target is ONE, this is not needed, which saves a declaration r::ONE->R.
--Compiletime checks are on context expressions minimal while still only used for Atlas.
--GEN/SPEC is not considered yet, while it does not work properly in PHP at this moment.

--WHILE GEN does not work well in prototype it is best to first define relations on 
--specific concept -> general properties are translated into columns at the end, so they can be removed more easily


PATTERN Atlas
thepicture::Picture->Picture.

-- a relation variable can be overloaded -> no function
-- TODO -> namespaces?
relvar::Relation*Type.
contains::Relation*Pair.
contains::Concept*Atom.

source::Type->Concept.
target::Type->Concept.

--IsaRelation contains only user-defined isa relations, not derived ones
specific::IsaRelation->Concept. 
general::IsaRelation->Concept.
ENDPATTERN
PATTERN Rules

{--SPECIFIC RULE DECLARATIONS--}
--GEN UserRule ISA Rule
--GEN MultiplicityRule ISA Rule
--GEN HomogeneousRule ISA Rule
property::MultiplicityRule->Prop.
on::MultiplicityRule->Relation.
property::HomogeneousRule->Prop.
on::HomogeneousRule->Relation.

{--GENERAL RULE DECLARATIONS--}
--GEN Rule ISA Expression
--GEN Morphism ISA Expression
--type::Expression->Type.
type::Rule->Type.
type::UserRule->Type.
type::MultiplicityRule->Type.
type::HomogeneousRule->Type.
--type::Morphism->Type.
violates::Violation*Rule.
violates::Violation*UserRule.
violates::Violation*MultiplicityRule.
violates::Violation*HomogeneousRule.
explanation::Rule->Explanation.
explanation::UserRule->Explanation.
explanation::MultiplicityRule->Explanation.
explanation::HomogeneousRule->Explanation.


ENDPATTERN

PATTERN ExplicitUserContext
s::User*User. -- =[ ("PWO_gmi","PWO_gmi") ].
s::Script*Script. -- =[ ("test.adl","test.adl") ].

--KEY ctx : I[Picture] [user : user , script : s[Script*Script] ]
--display;display~ /\ user;s;user~ /\ script;s;script~ |- I[Picture]
user::Picture->User.
user::Relation->User.
user::Type->User.
user::Pair->User.
user::Concept->User.
user::Atom->User.
user::IsaRelation->User.
user::MultiplicityRule->User.
user::HomogeneousRule->User.
user::Prop->User.
user::UserRule->User.
user::Rule->User.
user::Violation->User.
user::Explanation->User.
--ctxenv::Picture*Picture.
--ctxenv::Relation*Relation.
--ctxenv::Concept*Concept.
--ctxenv::IsaRelation*IsaRelation.
--ctxenv::MultiplicityRule*MultiplicityRule.
--ctxenv::HomogeneousRule*HomogeneousRule.
--ctxenv::UserRule*UserRule.
--ctxenv::Rule*Rule.
script::Picture->Script.
script::Relation->Script.
script::Type->Script.
script::Pair->Script.
script::Concept->Script.
script::Atom->Script.
script::IsaRelation->Script.
script::MultiplicityRule->Script.
script::HomogeneousRule->Script.
script::Prop->Script.
script::UserRule->Script.
script::Rule->Script.
script::Violation->Script.
script::Explanation->Script.

--All Atlas concepts need to be qualified identity strings to prevent mixture of adl scripts
display::Picture->String.
display::Relation->String.
display::Type->String.
display::Pair->String.
display::Concept->String.
display::Atom->String.
display::IsaRelation->String.
display::MultiplicityRule->String.
display::HomogeneousRule->String.
display::Prop->String.
display::UserRule->String.
display::Rule->String.
display::Violation->String.
display::Explanation->String.
ENDPATTERN
{- TODO -> Manual replace: user;s;user[MultiplicityRule*User]~ /\ script;s;script~
REASON=it looks like a non-performing query, at least on my laptop
SELECT DISTINCT TODO.`i`, TODO.`i` AS i1
FROM `#TABLE#` AS TODO
WHERE TODO.`script`='".$_REQUEST['Script']."'
  AND TODO.`user`='".$_REQUEST['User']."'
-}
--TODO -> Do not use parent expression as Header, but give one of the service attributes this property
--        When using user-unfriendly id's I do not want the id as a header -> I want to choose.
SERVICE Rules : I[ONE]
   = [ "Conceptual diagram"{"PICTURE"}: V[ONE*Picture];(user;s;user[Picture*User]~ /\ script;s;script~);display
     , "User-defined rules" : V[ONE*UserRule];(user;s;user[UserRule*User]~ /\ script;s;script~)
         = [ rule : I[UserRule];display
           , source : type;source;display
           , target : type;target;display
           , violations : violates~;display
           ]
     , Multiplicities : V[ONE*MultiplicityRule];(user;s;user[MultiplicityRule*User]~ /\ script;s;script~)
         = [ property : property;display
           , source : type;source;display
           , on : on;display
           , rule : I[MultiplicityRule];display
           , violations : violates~;display
           ]
     , "Homogeneous properties" : V[ONE*HomogeneousRule];(user;s;user[HomogeneousRule*User]~ /\ script;s;script~)
         = [ property : property;display
           , on : on;display
           , rule : I[HomogeneousRule];display
           , violations : violates~;display
           ]
      ] 

--TODO -> specific types moeten doorlinken naar generiekere service, als geen specifieke service bestaat
--TODO -> relations op generieke types moeten herkend worden, zodat juiste SQL gemaakt kan worden
--        nu wordt default de specieke tabel gebruikt voor alle relaties!
SERVICE Rule : I[Rule]
   = [ object : display
     , source : type;source;display
     , target : type;target;display
     , violations : violates~;display
     , explanation : explanation;display]
SERVICE Rule1 : I[UserRule]
   = [ object : display
     , source : type;source;display
     , target : type;target;display
     , violations : violates~;display
     , explanation : explanation;display]
SERVICE Rule2 : I[MultiplicityRule]
   = [ object : display
     , source : type;source;display
     , target : type;target;display
     , violations : violates~;display
     , explanation : explanation;display]
SERVICE Rule3 : I[HomogeneousRule]
   = [ object : display
     , source : type;source;display
     , target : type;target;display
     , violations : violates~;display
     , explanation : explanation;display]

SERVICE "ISArelations" : I[ONE]
   = [ "IS-a relations" :  V[ONE*IsaRelation];(user;s;user[IsaRelation*User]~ /\ script;s;script~)
      = [ "IS-a relation" : I[IsaRelation];display
        , specific : specific;display
        , isa : general;display
        ]
     ]

--I must use a nested name to display, because there is no SERVICE on String only on Relation
SERVICE Relations : I[ONE]
   = [ Relation_s : V[ONE*Relation];(user;s;user[Relation*User]~ /\ script;s;script~)
      = [name:display]
     ]

--I do not want to display the qualified name, but the unqualified one 
SERVICE Relation   : I[Relation]
   = [ name        : display
     , type        : relvar;display
     , "source(s)" : relvar;source;display
     , "target(s)" : relvar;target;display
     , "multiplicity properties"  : (on[MultiplicityRule*Relation])~;property;display
     , "homogeneous properties"  : (on[HomogeneousRule*Relation])~;property;display
     , population  : contains;display]

SERVICE Concepts : I[ONE]
   = [ Concept_s : V[ONE*Concept];(user;s;user[Concept*User]~ /\ script;s;script~);display]

SERVICE Concept : I[Concept]
   = [ population : contains;display]

ENDCONTEXT

{- Gezocht wordt naar de kolom UserRule, omdat dit zo bepaald is door het
type in de expressie. Maar deze kolom heeft de naam van het generale type Rule, omdat dit zo gedeclareerd is.
Eén of andere join nodig?

SELECT DISTINCT `f1`.`UserRule` AS `id`
FROM  ( SELECT DISTINCT csnd.i AS `UserRule`
FROM `userrule` AS csnd
) AS f1



SELECT DISTINCT 
  `f3`.`UserRule` AS `id`
  ,`f3`.`UserRule` AS `rule`
  , `f3`.`source`
FROM `userrule`
LEFT JOIN  
  ( SELECT DISTINCT F0.`UserRule`, F1.`source`
    FROM `rule` AS F0, `type` AS F1
    WHERE F0.`Type`=F1.`i`
   ) AS f3
ON `f3`.`UserRule`='accepted |- addressedTo~'
WHERE `userrule`.`i`='accepted |- addressedTo~'


SELECT DISTINCT 
     'paid |- sentTo~' AS `id` 
   , 'paid |- sentTo~' AS `rule`
   , `f3`.`source` 
FROM `userrule` 
LEFT JOIN 
     ( SELECT DISTINCT 
            F0.`UserRule`
          , F1.`source` 
       FROM `rule` AS F0, `type` AS F1 
       WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`UserRule`='paid |- sentTo~' 
WHERE `userrule`.`i`='paid |- sentTo~'

SELECT DISTINCT 
     'paid |- sentTo~' AS `id` 
   , 'paid |- sentTo~' AS `rule`
   , `f3`.`source` 
FROM `userrule` 
LEFT JOIN 
     ( SELECT DISTINCT 
            F0.`i`
          , F1.`source` 
       FROM `rule` AS F0, `type` AS F1 
       WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='paid |- sentTo~' 
WHERE `userrule`.`i`='paid |- sentTo~'

-------------------------------------
SELECT DISTINCT `f1`.`Violation` AS `violations` FROM `userrule` JOIN `violates` AS f1 ON `f1`.`UserRule`='accepted;of~ |- provided' WHERE `userrule`.`i`='accepted;of~ |- provided'
----------------------------------------------------
SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `f2`.`property` 
  , `f3`.`source` 
  , `f4`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN `multiplicityrule` AS f2 
ON `f2`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`MultiplicityRule`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`MultiplicityRule`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN `multiplicityrule` AS f4 
ON `f4`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'

SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `f2`.`property` 
  , `f3`.`source` 
  , `f4`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN `multiplicityrule` AS f2 
ON `f2`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`i`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN `multiplicityrule` AS f4 
ON `f4`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'


SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `multiplicityrule`.`property` 
  , `f3`.`source` 
  , `multiplicityrule`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`i`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'
-}
