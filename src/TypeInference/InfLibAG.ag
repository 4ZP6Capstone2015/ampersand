--option d -> generate data types for DATA (-r to garantee unique constuctor names)
--            MOVE generated data types to module InfLibAGFuncs
--
--option -f -> generate semantic functions
--option -c (catamorphism) -> generate sem_* function (-s -> with type signature)
--option -w (wrapper) -> generate inherited and synthesized data types + functions (data *_Inh + *_Syn; wrap_*) 

--   Can I generate labels with -d?
--
--TODO -> merge data structures with Adl data structures into new solid/correct Adl data structures (zie Adl conversie)

DATA RelAlgExpr  
  |ISect  sublst:ISectList
  |Union  sublst:UnionList
  |Comp   lsub:RelAlgExpr rsub:RelAlgExpr
  |RAdd   lsub:RelAlgExpr rsub:RelAlgExpr
  |Compl  sub:RelAlgExpr
  |Conv   sub:RelAlgExpr
  |Implic lsub:RelAlgExpr rsub:RelAlgExpr
  |Equiv  lsub:RelAlgExpr rsub:RelAlgExpr
  |Morph  rel:RelAlgMorph usertype:RelAlgType locid:Int

DERIVING RelAlgExpr : Show

TYPE ISectList = [RelAlgExpr]
TYPE UnionList = [RelAlgExpr]

ATTR RelAlgExpr ISectList UnionList
   [ {-inherited attributes: are copied down by default-}
     env_decls:{[RelDecl]}
     env_isa:Isa
     type_down:RelAlgType
     listof:ListOf
   | {-chain attributes-}
   | {-synthesized attributes-}
     me:SELF --copy of myself to investigate me
     env_in:AltList
     rtype:InfType
     env_mph:{[(RelAlgExpr,InfType,RelDecl)]}
     inftree:InfTree
   ]

SEM ISectList UnionList
  |Nil  lhs.env_in = Left []
        lhs.rtype = fatal 45 "undefined rtype on Nil of ISect-/UnionList"
        lhs.env_mph = []
        lhs.inftree = fatal 47 "undefined inftree on Nil of ISect-/UnionList"
  |Cons lhs.env_in = @env
        loc.env = alts_ababab (@hd.me,@tl.me) @lhs.env_isa @hd.env_in @tl.env_in
        loc.tp = if null @tl.me 
                 then final_infer_ababab @lhs.env_isa (inferencerule_ababab @lhs.listof @hd.me [])
                                         (Left @lhs.type_down) @hd.env_in (Left (Universe,Universe)) --the tail is universe
                 else final_infer_ababab @lhs.env_isa (inferencerule_ababab @lhs.listof @hd.me @tl.me)
                                         (Left @lhs.type_down) @hd.env_in @tl.rtype
        hd.type_down=if not(is_type_error @tp) then thetype @tp else fatal 55 "There should be a ababab error"
        lhs.rtype = @tp
        lhs.env_mph = @hd.env_mph ++ @tl.env_mph
        loc.hdax = headofaxiomlist (inferencerule_ababab @lhs.listof @hd.me @tl.me) @tp @hd.inftree
        lhs.inftree = if null @tl.me
                      then @hdax --the tree of (take 1 exprlist)
                      else axiomlist @tp @hdax @tl.inftree --all the axioms
SEM RelAlgExpr
  |ISect  sublst.listof = ListOfISect 
      --    lhs.inftree = InfExprs (inferencerule_ababab_list ListOfISect @sublst.me) @sublst.inftree
  |Union  sublst.listof = ListOfUnion
      --    lhs.inftree = InfExprs (inferencerule_ababab_list ListOfUnion @sublst.me) @sublst.inftree
  |ISect Union
          lhs.env_in = @env 
          loc.env = @sublst.env_in
          sublst.type_down = push_type_ababab @lhs.type_down
          lhs.rtype = @sublst.rtype 
          lhs.env_mph = @sublst.env_mph
          lhs.inftree = @sublst.inftree 
  |Comp RAdd
          lhs.env_in = @env 
          loc.env = alts_abbcac (@lsub.me,@rsub.me) @lhs.env_isa @lsub.env_in @rsub.env_in
          loc.t = push_type_abbcac (@lsub.me,@rsub.me) @lhs.env_isa (inferencerule_abbcac @me) @lhs.type_down @lsub.env_in @rsub.env_in
          loc.(_,cb) = @ltp
          lsub.type_down = @ltp
          loc.ltp = if not(is_b_error @t) then lefttype @t else fatal 65 "There should be an ambiguous b error"                
          rsub.type_down = if not(is_b_error @t) then righttype @t else fatal 66 "There should be an ambiguous b error"
          lhs.rtype = @tp
          loc.tp = if not(is_b_error @t)
                   then final_infer_abbcac @lhs.env_isa @lsub.rtype @rsub.rtype
                   else Right(b_error @t)
          lhs.env_mph = @lsub.env_mph ++ @rsub.env_mph
          lhs.inftree = InfExprs (inferencerule_abbcac @me) (inferred @tp,@cb) [@lsub.inftree,@rsub.inftree]
  |Compl  lhs.env_in = alts_compl @me @sub.env_in 
          sub.type_down = push_type_abab @lhs.type_down
          loc.tp = {case @me of
                       Compl (Morph{}) -> @sub.rtype
                       _ -> error "complements on mphs only -> normalize"}
          lhs.rtype = @tp
          lhs.env_mph = @sub.env_mph
          lhs.inftree = complement_rule @tp @sub.inftree
  |Conv   lhs.env_in = alts_abba @sub.env_in
          sub.type_down = push_type_abba @lhs.type_down
          lhs.rtype = @tp
          loc.tp = final_infer_conv @sub.rtype
          lhs.env_mph = @sub.env_mph
          lhs.inftree = InfExprs Conv_nc (inferred @tp,EmptyObject) [@sub.inftree]
  |Implic lhs.env_in = error "no implication rule symbols -> normalize"
          lhs.rtype = error "no implication rule symbols -> normalize"
          lhs.env_mph = error "no implication rule symbols -> normalize"
          lhs.inftree = error "no implication rule symbols -> normalize"
  |Equiv  lhs.env_in = error "no equivalence rule symbols -> normalize"
          lhs.rtype = error "no equivalence rule symbols -> normalize"
          lhs.env_mph = error "no equivalence rule symbols -> normalize"
          lhs.inftree = error "no equivalence rule symbols -> normalize"
  |Morph  lhs.env_in = @env
          loc.env = alts_mph @lhs.env_decls @lhs.env_isa @me
          loc.(t,tree) = final_infer_mph @lhs.env_decls @me @lhs.env_isa @lhs.type_down @env
          lhs.rtype = @t
          lhs.env_mph = [( @me, @t, thedecl @lhs.env_decls @lhs.env_isa @me @t)]
          lhs.inftree = @tree



{
module TypeInference.InfLibAG 
  (infer
  ,RelAlgExpr(..)
  ,RelAlgMorph(..)
  ,RelDecl(..) 
  ,RelAlgObj(..)
  ,RelAlgType
  ,Isa
  ,TError(..)
  ,InfTree(..)
  ,DeclRuleType(..)
  ,InfRuleType(..)
  ) where

import TypeInference.InfLibAGFuncs

infer:: [RelDecl] -> Isa -> RelAlgExpr -> Either (RelAlgType,[(RelAlgExpr,RelAlgType,RelDecl)],InfTree) TError
infer reldecls isas root_expr =
  case rtype of
    Left (x,y) -> if x==Universe 
                  then Right$TErrorU "The source of the expression is the universal set" 
                  else if  y==Universe
                       then Right$TErrorU "The target of the expression is the universal set" 
                       else Left ((x,y), env_mph, inftree)
    Right err -> Right err
  where
  inftree = inftree_Syn_RelAlgExpr (agtree (head alltypes))
  env_mph = [(m,t,d)|(m,Left t,d)<-env_mph_Syn_RelAlgExpr (agtree (head alltypes))]
  env_in = env_in_Syn_RelAlgExpr (agtree (Universe,Universe))
  rtype = if length alltypes==1 
          then rtype_Syn_RelAlgExpr (agtree (head alltypes)) --finalize by pushing the type down again
          else if null alltypes
               then Right env_in_err
               else Right$TErrorAmb "Ambiguous type" alltypes
  alltypes = case env_in of
     Left xs -> if null xs 
                then fatal 214 "the AltList cannot be Left []."
                else xs 
     _ -> []
  Right env_in_err = env_in
  agtree push = wrap_RelAlgExpr (sem_RelAlgExpr$normalise$root_expr)$Inh_RelAlgExpr reldecls isas NoListOf push

----------------------------------------------------------------------------
--TEST
----------------------------------------------------------------------------
{-
main :: IO ()
main = print$show$[case result1 test of Left t -> (result1 test,result2 test); x -> (x,[]); |test<-tests]
--main = print$show [result0 test|test<-tests]

--testTree :: Tree
--testTree = Node (Tip 1) (Node (Tip 2) (Tip 3))
r0 = Morph (DRel "r0" ) (Universe,Universe) 1
r = Morph (DRel "r" ) (Universe,Universe) 1
s = Morph (DRel "s" ) (Universe,Universe) 1
ramb = Morph (DRel "ramb" ) (Universe,Universe) 1
ramb1 = Morph (DRel "ramb") (Object "A1",Object "B") 1
ramb2 = Morph (DRel "ramb") (Object "A2",Object "B") 1

testcpts = [Object "A",Object "A1",Object "A2",Object "B",Object "C",Object "D"]
--testisa = [(x,Universe)|x<-testcpts]++[(Universe,x)|x<-testcpts]++[(x,x)|x<-testcpts]
--testdecls = [RelDecl "ramb" (Object "A1",Object "B")
  --          ,RelDecl "ramb" (Object "A2",Object "B")
    --        ,RelDecl "s" (Object "C",Object "D")
      --      ,RelDecl "r" (Object "A",Object "B")]

testdecls = [RelDecl {dname = "item", dtype = (Object "Order",Object "Product")},RelDecl {dname = "item", dtype = (Object "Delivery",Object "Product")},RelDecl {dname = "of", dtype = (Object "Delivery",Object "Order")},RelDecl {dname = "provided", dtype = (Object "Provider",Object "Delivery")},RelDecl {dname = "accepted", dtype = (Object "Provider",Object "Order")},RelDecl {dname = "addressedTo", dtype = (Object "Order",Object "Provider")},RelDecl {dname = "deliveredTo", dtype = (Object "Delivery",Object "Client")},RelDecl {dname = "from", dtype = (Object "Order",Object "Client")},RelDecl {dname = "sentTo", dtype = (Object "Invoice",Object "Client")},RelDecl {dname = "delivery", dtype = (Object "Invoice",Object "Delivery")},RelDecl {dname = "from", dtype = (Object "Invoice",Object "Provider")},RelDecl {dname = "", dtype = (Universe,Universe)}]

testisa = [(Universe,Universe),(Object "Client",Universe),(Object "Client",Object "Client"),(Object "Delivery",Universe),(Object "Delivery",Object "Delivery"),(Object "Invoice",Universe),(Object "Invoice",Object "Invoice"),(Object "Order",Universe),(Object "Order",Object "Order"),(Object "Product",Universe),(Object "Product",Object "Product"),(Object "Provider",Universe),(Object "Provider",Object "Provider"),(EmptyObject,Object "Client"),(EmptyObject,Object "Delivery"),(EmptyObject,Object "Invoice"),(EmptyObject,Object "Order"),(EmptyObject,Object "Product"),(EmptyObject,Object "Provider"),(EmptyObject,EmptyObject),(EmptyObject,Object "S"),(Object "S",Universe),(Object "S",Object "S")]


tests = [test99]
tests0 = [test0a,test0b]
tests1 = [test1]
tests2 = [test2a,test2b]
tests3 = [test3a,test3b,test3c]
tests6 = [test6a,test6b]
tests7 = [test7a,test7b,test7c,test7d]
--test :: T_Tree
--test = sem_Tree testTree
test1::T_RelAlgExpr
test0a = sem_RelAlgExpr r
test0b= sem_RelAlgExpr ramb
test1= sem_RelAlgExpr (compl r /\ r)
test2a= sem_RelAlgExpr (s /\ r /\ r)
test2b= sem_RelAlgExpr (r /\ r /\ s)
test3a= sem_RelAlgExpr ((conv r) /\ (conv r) /\ (conv r))
test3b= sem_RelAlgExpr ((conv r) /\ (conv r) /\ ( r))
test3c= sem_RelAlgExpr (( r) /\ (conv r) /\ (conv r))
test4= sem_RelAlgExpr (r /\ r /\ r)
test5= sem_RelAlgExpr (r /\ r /\ r0)
test6a= sem_RelAlgExpr (r *.* (conv r))
test6b= sem_RelAlgExpr (r *.* r)
test7a= sem_RelAlgExpr (ramb *.* (conv ramb))
test7b= sem_RelAlgExpr ((conv ramb) *.* ramb1)
test7c= sem_RelAlgExpr ((conv ramb) *.* ramb2)
test7d= sem_RelAlgExpr (ramb *.* r)
test99 = sem_RelAlgExpr$
             ISect[
                  Union [Morph (DRel {rname = "sentTo"}) (Universe,Universe) 1,
                      Comp ( (Morph (DRel {rname = "delivery"}) (Universe,Universe) 2)) 
                            (Comp ( (Morph (DRel {rname = "of"}) (Universe,Universe) 3)) 
                                  ( (Morph (DRel {rname = "from"}) (Universe,Universe) 4))
                             )
                      ]
               ,Union [Compl (Morph (DRel {rname = "sentTo"}) (Universe,Universe) 5)
                      ,Comp (Morph (DRel {rname = "delivery"}) (Universe,Universe) 6) 
                            (Comp (Morph (DRel {rname = "of"}) (Universe,Universe) 7) 
                                  (Morph (DRel {rname = "from"}) (Universe,Universe) 8))]]


result0 :: T_RelAlgExpr -> AltList
result1 :: T_RelAlgExpr -> InfType
result2 :: T_RelAlgExpr -> [(RelAlgExpr, InfType, RelDecl)]
--result :: [Int]
--result = front_Syn_Tree (wrap_Tree test Inh_Tree)
result0 test = env_in_Syn_RelAlgExpr (wrap_RelAlgExpr test (Inh_RelAlgExpr testdecls testisa NoListOf (Universe,Universe)  ) ) 
result1 test = rtype_Syn_RelAlgExpr (wrap_RelAlgExpr test (Inh_RelAlgExpr testdecls testisa NoListOf (Universe,Universe)  ) ) 
result2 test = env_mph_Syn_RelAlgExpr (wrap_RelAlgExpr test (Inh_RelAlgExpr testdecls testisa NoListOf (Universe,Universe)  ) ) 
-}
}

