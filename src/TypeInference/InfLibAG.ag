--option d -> generate data types for DATA (-r to garantee unique constuctor names)
--option -f -> generate semantic functions
--option -c (catamorphism) -> generate sem_* function (-s -> with type signature)
--option -w (wrapper) -> generate inherited and synthesized data types + functions (data *_Inh + *_Syn; wrap_*) 

--   Can I generate labels with -d?
DATA RelAlgExpr  
  |ISect  sublst:ISectList
  |Union  sublst:UnionList
  |Comp   lsub:RelAlgExpr rsub:RelAlgExpr
  |RAdd   lsub:RelAlgExpr rsub:RelAlgExpr
  |Compl  sub:RelAlgExpr
  |Conv   sub:RelAlgExpr
  |Implic lsub:RelAlgExpr rsub:RelAlgExpr
  |Equiv  lsub:RelAlgExpr rsub:RelAlgExpr
  |Morph  rel:RelAlgMorph usertype:RelAlgType locid:Int

TYPE ISectList = [RelAlgExpr]
TYPE UnionList = [RelAlgExpr]

ATTR RelAlgExpr ISectList UnionList
   [ env_isa:{[Isa]}
     type_down:InfType
   | 
   | rtype:InfType
     errors:{[String]}
     me:SELF
     env_in:{AltList}
   ]

SEM ISectList UnionList
  |Nil  lhs.rtype = Left (Universe,Universe) --must be universe, because once it will be @tl.rtype
        lhs.errors = []
        lhs.env_in = Left []
  |Cons lhs.env_in = (@hd.env_in ++ @tl.env_in)
SEM ISectList
  |Cons lhs.rtype = Left (head @t)
        loc.t = infer_isect @hd.rtype [@tl.rtype]
        lhs.errors = if null(@hd.errors ++ @tl.errors)
                     then if null @t 
                            then ["ISect error (fatal?)"]
                            else amberrors @t 
                     else @hd.errors ++ @tl.errors
        
SEM UnionList
  |Cons lhs.rtype = head @t 
        loc.t = infer_union @hd.rtype [@tl.rtype]
        lhs.errors = if null(@hd.errors ++ @tl.errors)
                     then if null @t 
                            then ["Union error (fatal?)"]
                            else amberrors @t 
                     else @hd.errors ++ @tl.errors
SEM RelAlgExpr
  |ISect  lhs.rtype = @sublst.rtype
          lhs.errors = if null @sublst.errors 
                       then if null @t 
                            then ["ISect error"]
                            else amberrors @t 
                       else @sublst.errors 
          lhs.env_in = @env 
          loc.env = alts_isect @sublst.env_in
          loc.t = infer_isect @lhs.type_down @env
          sublst.type_down = if null @t then (EmptyObject,EmptyObject) else head @t
  |Union  lhs.rtype = @sublst.rtype
          lhs.errors = if null @sublst.errors 
                       then if null @t 
                            then ["Union error"]
                            else amberrors @t 
                       else @sublst.errors 
          lhs.env_in = @env 
          loc.env = alts_union @sublst.env_in
          loc.t = infer_union @lhs.type_down @env
          sublst.type_down = if null @t then (EmptyObject,EmptyObject) else head @t
  |Comp   lhs.rtype = infer_comp (Universe,Universe) [@lsub.rtype] [@rsub.rtype]
          lhs.errors = @lsub.errors ++ @rsub.errors
          lhs.env_in = alts_comp @lsub.env_in @rsub.env_in
          loc.t = infer_comp @lhs.type_down @lsub.env_in @rsub.env_in
          lsub.type_down = @t
          rsub.type_down = @t
  |RAdd   lhs.rtype =  infer_radd (Universe,Universe) [@lsub.rtype] [@rsub.rtype]
          lhs.errors = @lsub.errors ++ @rsub.errors
          lhs.env_in =  alts_radd @lsub.env_in @rsub.env_in
          loc.t = infer_radd @lhs.type_down @lsub.env_in @rsub.env_in
          lsub.type_down = @t
          rsub.type_down = @t
  |Compl  lhs.rtype = {case @me of
                          Compl (Morph{}) -> @sub.rtype
                          _ -> error "complements on mphs only -> normalize"}
          lhs.errors = {case @me of
                          Compl (Morph{}) -> @sub.errors
                          _ -> error "complements on mphs only -> normalize"}
          lhs.env_in = {case @me of
                            Compl (Morph{}) -> @sub.env_in
                            _ -> error "complements on mphs only -> normalize"}
  |Conv   lhs.rtype = infer_conv @sub.rtype
          lhs.errors = @sub.errors
          lhs.env_in = alts_conv @sub.env_in
          sub.type_down = infer_conv @lhs.type_down
  |Implic lhs.rtype = error "no implication rule symbols -> normalize"
          lhs.errors = error "no implication rule symbols -> normalize"
          lhs.env_in = error "no implication rule symbols -> normalize"
  |Equiv  lhs.rtype = error "no equivalence rule symbols -> normalize"
          lhs.errors = error "no equivalence rule symbols -> normalize"
          lhs.env_in = error "no equivalence rule symbols -> normalize"
  |Morph  lhs.rtype = @t
          loc.t = infer_homo @lhs.type_down
          lhs.errors = if @env==[] 
                       then ["Undeclared"] 
                       else [] --undeclared or ambiguous errors
          lhs.env_in = @env
          loc.env =  {case @me of
                             Morph (DRel _ alts') ut _ -> if ut==(Universe,Universe) 
                                                          then map dtype alts'
                                                          else [dt|dt<-map dtype alts', dt `isarelated` ut]
                             Morph _ ut _ -> [ut] }



{
module TypeInference.InfLibAG where


type InfType = Either RelAlgType String
type AltList = Either [RelAlgType] String

rd []        = []
rd (x:xs)    = x: rd [e|e<-xs, e/=x]


isarelated x y = x==y
checks [] = []
checks (x:xs) = [(x,x')|x'<-xs] ++ checks xs

alts_isect, alts_union, alts_conv :: [RelAlgType] -> [RelAlgType]
--DESCR -> alts_* takes list(s) of types and concludes possible types for this expression
alts_isect {-isas-} xs = rd [(x,y)|((x,y),(x',y'))<-checks xs
                                  ,(x,y)/=(Universe,Universe)
                                  ,(x',y')/=(Universe,Universe)
                                  ,x `isarelated` x'
                                  ,y `isarelated` y'] --TODO remove doubles
alts_union xs = rd [x|x<-xs,x/=(Universe,Universe)] --TODO remove doubles
alts_comp, alts_radd :: [RelAlgType] -> [RelAlgType] -> [RelAlgType]
alts_comp xs ys = rd [(x,z)|(x,y)<-xs,(y',z)<-ys, y `isarelated` y']
alts_radd xs ys = rd [(x,z)|(x,y)<-xs,(y',z)<-ys, y `isarelated` y']
alts_conv xs = rd [(y,x)|(x,y)<-xs]

errs xs = [x|Right x<-xs]
infer_isect, infer_union :: InfType -> [InfType] -> [RelAlgType]
infer_isect {-isas-} t xs = if null(errs (t:xs)) then alts_isect [x|Left x<-(t:xs)] else []
infer_union {-isas-} t xs = if null(errs (t:xs)) then alts_union [x|Left x<-(t:xs)] else []
infer_comp (Left (x',z')) xs ys = 
   if null(errs(xs++ys)) 
   then [(x,z)|(x,y)<-xs,(y',z)<-ys, x `isarelated` x', z `isarelated` z' ,y `isarelated` y'] 
   else [] 
infer_comp _ _ _ = []
infer_radd (Left (x',z')) xs ys = 
   if null(errs(xs++ys)) 
   then [(x,z)|(x,y)<-xs,(y',z)<-ys, x `isarelated` x', z `isarelated` z' ,y `isarelated` y'] 
   else []
infer_radd _ _ _ = []
infer_conv,infer_homo :: RelAlgType -> RelAlgType
infer_conv (x,y) = (y,x)
infer_homo x = x
amberrors xs = ["Ambiguous ISect"++show x|x<-xs,isamb xs]
isamb xs = length xs>1
isnotype xs = null xs

--inferAG::ICtx -> NormExpr -> TypedExpr
--inferAG cx exprIn = exprout
--  where
--  exprOut = 
--  errorsOut = errors_Syn_

main :: IO ()
main = print (if null result2 then(show result1) else(show result2))

--testTree :: Tree
--testTree = Node (Tip 1) (Node (Tip 2) (Tip 3))
r0 = Morph (DRel "r" []) (Universe,Universe) 1
r = Morph (DRel "r" [RelDecl "r" (Object "A",Object "B")]) (Universe,Universe) 1
s = Morph (DRel "s" [RelDecl "s" (Object "C",Object "D")]) (Universe,Universe) 1
(/\) x y = ISect [x,y]
compl x = Compl x

--test :: T_Tree
--test = sem_Tree testTree
test::T_RelAlgExpr
test= sem_RelAlgExpr (compl r /\ s)

--result :: [Int]
--result = front_Syn_Tree (wrap_Tree test Inh_Tree)
result1 = rtype_Syn_RelAlgExpr (wrap_RelAlgExpr test (Inh_RelAlgExpr [{-Isa-}] (Universe,Universe) ) ) 
result2 = errors_Syn_RelAlgExpr (wrap_RelAlgExpr test (Inh_RelAlgExpr [{-Isa-}] (Universe,Universe) ) ) 


--the heterogeneous relation algebra with a possibility to explicitly declare types on morphisms in an expression
--a is a data structure for storing language statement meta data like file position of a declaration

data RelAlgMorph = 
   DRel {rname::String, alts::[RelDecl]}
  |IdRel
  |VRel
  deriving (Show)
data RelAlgObj = Universe | EmptyObject | Object String deriving (Show,Eq)
type RelAlgType = (RelAlgObj, RelAlgObj)
data Isa = Isa (RelAlgObj, RelAlgObj)
data RelDecl = RelDecl {dname::String, dtype::RelAlgType} | IDecl | VDecl deriving (Show)
}

