module Database.Design.Ampersand.Prototype.GenFrontend (doGenFrontend) where

import Prelude hiding (putStrLn)
import Data.Maybe
import System.FilePath
import Database.Design.Ampersand.Basics
import Database.Design.Ampersand.Misc
import Database.Design.Ampersand.Core.AbstractSyntaxTree
import Database.Design.Ampersand.FSpec.FSpec
import Database.Design.Ampersand.Prototype.ProtoUtil

fatal :: Int -> String -> a
fatal = fatalMsg "GenFrontend"

doGenFrontend :: FSpec -> IO ()
doGenFrontend fSpec =
 do { putStrLn "Generating new frontend.." 
    ; let feInterfaces = buildInterfaces fSpec
    ; traverseInterfaces fSpec feInterfaces
    ; return ()
    }

-- TODO: interface ref: Editable relations from interface def of ref, or origin?
--       both may result in unexpected editability. Maybe take intersection?

data FEInterface = FEInterface String FEObject deriving Show

data FEObject = FEObject String FESubinterface deriving Show

-- subinterface/subobject?
data FESubinterface = FEBox (Maybe String) [FEObject] | FEAtoms deriving Show

buildInterfaces :: FSpec -> [FEInterface]
buildInterfaces fSpec = map (buildInterface fSpec) $ interfaceS fSpec

buildInterface :: FSpec -> Interface -> FEInterface
buildInterface fSpec interface = FEInterface (name interface) $ buildObject fSpec {- (ifcParams interface) -} (ifcObj interface)
    

buildObject :: FSpec -> ObjectDef -> FEObject
buildObject fSpec object = FEObject (name object) $ buildSubinterface fSpec (objmsub object)

buildSubinterface :: FSpec -> Maybe SubInterface -> FESubinterface
buildSubinterface fSpec mSubIfc =
  case mSubIfc of
    Just (InterfaceRef nm) -> case filter (\ifc -> name ifc == nm) $ interfaceS fSpec of -- Follow interface refs
                                [i] -> buildSubinterface fSpec (objmsub $ ifcObj i) -- TODO: skip interface root object, what about exp and editable rels?
                                []  -> fatal 44 $ "Referenced interface " ++ nm ++ " missing"
                                _   -> fatal 45 $ "Multiple declarations of referenced interface " ++ nm
    Just (Box _ cl objects) -> FEBox cl $ map (buildObject fSpec) objects
    Nothing                 -> FEAtoms



traverseInterfaces :: FSpec -> [FEInterface] -> IO ()
traverseInterfaces fSpec ifcs =
 do { putStrLn $ show $ map name (interfaceS fSpec)
    ; mapM_ (traverseInterface fSpec) $ ifcs
    }

traverseInterface :: FSpec -> FEInterface -> IO ()
traverseInterface fSpec (FEInterface nm obj) =
 do { verboseLn (getOpts fSpec) $ "\nTop-level interface: " ++ nm
    ; lns <- traverseObject fSpec 0 Nothing obj
    ; let filename = nm ++ ".html" -- TODO: escape
    ; let header = "<!-- View for interface " ++ nm ++ ". Generated code, do not edit. -->\n<!-- Generated by " ++ ampersandVersionStr ++ " -->"
    ; writePrototypeFile fSpec ("views" </> filename) $ unlines (header : lns) 
    }

traverseObject :: FSpec -> Int -> Maybe String -> FEObject -> IO [String]
traverseObject fSpec depth mParentClass (FEObject nm subifc) =
 do { verboseLn (getOpts fSpec) $ replicate depth ' ' ++ nm
    ; let lns = [fromMaybe "BOX" mParentClass ++ "-CHILD:" ++ nm]
    ; lns' <- traverseSubinterface fSpec depth subifc
    ; return $ lns ++ lns'
    }

traverseSubinterface :: FSpec -> Int -> FESubinterface -> IO [String]
traverseSubinterface fSpec depth subIntf =
  case subIntf of
    FEBox cl objects ->
     do { verboseLn (getOpts fSpec) $ replicate depth ' ' ++ "BOX" ++ maybe "" (\c -> "<"++c++">") cl
        ; let lns = ["BOX" ++ maybe "" (\c -> "<"++c++">") cl]
        ; lnss <- mapM (traverseObject fSpec (depth + 1) cl) objects
        ; return $ indent 2 $ lns ++ indent 2 (concat lnss)
        }
    FEAtoms -> return []
