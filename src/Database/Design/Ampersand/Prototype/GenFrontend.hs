module Database.Design.Ampersand.Prototype.GenFrontend (doGenFrontend) where

import Prelude hiding (putStrLn)
import Data.Maybe
import System.FilePath
import Database.Design.Ampersand.Basics
import Database.Design.Ampersand.Misc
import Database.Design.Ampersand.Core.AbstractSyntaxTree
import Database.Design.Ampersand.FSpec.FSpec
import Database.Design.Ampersand.Prototype.ProtoUtil

fatal :: Int -> String -> a
fatal = fatalMsg "GenFrontend"

doGenFrontend :: FSpec -> IO ()
doGenFrontend fSpec =
 do { putStrLn "Generating new frontend.." 
    ; traverseInterfaces fSpec
    }

traverseInterfaces :: FSpec -> IO ()
traverseInterfaces fSpec =
 do { putStrLn $ show $ map name (interfaceS fSpec)
    ; mapM_ (traverseInterface fSpec) $ interfaceS fSpec
    }
    
traverseInterface :: FSpec -> Interface -> IO ()
traverseInterface fSpec interface =
 do { verboseLn (getOpts fSpec) $ "\nTop-level interface: " ++ name interface
    ; lns <- traverseObjectDef fSpec (ifcParams interface) 0 Nothing (ifcObj interface)
    ; let filename = name interface ++ ".html" -- TODO: escape
    ; let header = "<!-- View for interface " ++ name interface ++ ". Generated code, do not edit. -->\n<!-- Generated by " ++ ampersandVersionStr ++ " -->"
    ; writePrototypeFile fSpec ("views" </> filename) $ unlines (header : lns) 
    }

traverseObjectDef :: FSpec -> [Expression] -> Int -> Maybe String -> ObjectDef -> IO [String]
traverseObjectDef fSpec editableRels depth mClass object =
 do { verboseLn (getOpts fSpec) $ replicate depth ' ' ++ name object
    ; let lns = [fromMaybe "" mClass ++ ":" ++ name object]
    ; lns' <- traverseMSubInterface fSpec editableRels depth (objmsub object)
    ; return $ lns ++ lns'
    }

traverseMSubInterface :: FSpec -> [Expression] -> Int -> Maybe SubInterface -> IO [String]
traverseMSubInterface fSpec editableRels depth subIntf =
  case subIntf of
    Just (InterfaceRef nm) -> case filter (\ifc -> name ifc == nm) $ interfaceS fSpec of -- Follow interface refs
                                [i] -> traverseObjectDef fSpec (ifcParams i) depth Nothing (ifcObj i)
                                []  -> fatal 44 $ "Referenced interface " ++ nm ++ " missing"
                                _   -> fatal 45 $ "Multiple declarations of referenced interface " ++ nm
    Just (Box _ cl objects) ->
     do { verboseLn (getOpts fSpec) $ replicate depth ' ' ++ "BOX" ++ maybe "" (\c -> "<"++c++">") cl
        ; let lns = ["BOX" ++ maybe "" (\c -> "<"++c++">") cl]
        ; lnss <- mapM (traverseObjectDef fSpec editableRels (depth + 1) cl) objects
        ; return $ lns ++ indent 2 (concat lnss)
        }
    Nothing ->
     do { 
        ; return []
        }
