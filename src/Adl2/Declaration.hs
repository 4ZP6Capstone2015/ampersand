{-# OPTIONS_GHC -Wall #-}
module Adl2.Declaration where
   import Adl2.Concept
   import Adl.Prop
   import Adl.Pair
   import Adl.FilePos
   import CommonClasses  ( Identified(..))
   import Data.List
   
   data Declaration = 
           Sgn { decnm   :: String  -- ^ the name of the declaration
               , desrc   :: Concept -- ^ the source concept of the declaration
               , detrg   :: Concept -- ^ the target concept of the declaration
                 --multiplicities returns decprps_calc so if you only need the user defined properties do not use multiplicities but decprps
               , decprps :: Props   -- ^ the user defined multiplicity properties (Uni, Tot, Sur, Inj) and algebraic properties (Sym, Asy, Trn, Rfx)
               , decprps_calc :: Props   -- ^ the calculated and user defined multiplicity properties (Uni, Tot, Sur, Inj) and algebraic properties (Sym, Asy, Trn, Rfx)
               , decprL  :: String  -- ^ three strings, which form the pragma. E.g. if pragma consists of the three strings: "Person ", " is married to person ", and " in Vegas."
               , decprM  :: String  -- ^    then a tuple ("Peter","Jane") in the list of links means that Person Peter is married to person Jane in Vegas.
               , decprR  :: String
               , decpopu :: Pairs   -- ^ the list of tuples, of which the relation consists.
               , decfpos :: FilePos -- ^ the position in the ADL source file where this declaration is declared.
               , decid   :: Int     -- ^ a unique number that can be used to identify the relation
               , deciss  :: Bool    -- ^ if true, this is a signal relation; otherwise it is an ordinary relation.
               , decusr  :: Bool    -- ^ if true, this relation is declared in the ADL-script; otherwise it was generated by ADL.
               , decpat  :: String  -- ^ the pattern where this declaration has been declared.
               , decplug :: Bool    -- ^ if true, this relation may not be stored in or retrieved from the standard database (it should be gotten from a Plug of some sort instead)
               }
          | Isn 
               { degen :: Concept  -- ^ The generic concept
               , despc :: Concept  -- ^ The specific concept
               }
          | Iscompl 
               { degen :: Concept
               , despc :: Concept
               }
          | Vs 
               { degen :: Concept
               , despc :: Concept
               }

-- \***********************************************************************
-- \*** Eigenschappen met betrekking tot: Declaration                   ***
-- \***********************************************************************
   instance Eq Declaration where
      d == d' = name d==name d' && source d==source d' && target d==target d'
   instance Show Declaration where
    showsPrec _ d
     = showString (intercalate " " [decnm d,"::",name (desrc d),"*",name (detrg d)
                                   ,show (decprps_calc d)
                                   ,"PRAGMA",show (decprL d)
                                            ,show (decprM d)
                                            ,show (decprR d)
                                   ]
                  )
   instance Identified Declaration where
    name d@Sgn{}   = decnm d
    name Isn{}     = "I"
    name Iscompl{} = "-I"
    name Vs{}      = "V"

   instance Association Declaration where
      source d = case d of
                   Sgn {}    -> desrc d
                   Isn {}    -> despc d
                   Iscompl{} -> despc d
                   Vs {}     -> degen d
      target d = case d of
                   Sgn {}    -> detrg d
                   Isn {}    -> degen d
                   Iscompl{} -> degen d
                   Vs {}     -> despc d
    --sign is vanzelf al geregeld...

